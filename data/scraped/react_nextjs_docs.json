[
  {
    "title": "React DOM APIs",
    "content": "API Reference\nReact DOM APIs\nThe\nreact-dom\npackage contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native.\nAPIs\nThese APIs can be imported from your components. They are rarely used:\ncreatePortal\nlets you render child components in a different part of the DOM tree.\nflushSync\nlets you force React to flush a state update and update the DOM synchronously.\nResource Preloading APIs\nThese APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used.\nReact-based frameworks\nfrequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework‚Äôs documentation for details.\nprefetchDNS\nlets you prefetch the IP address of a DNS domain name that you expect to connect to.\npreconnect\nlets you connect to a server you expect to request resources from, even if you don‚Äôt know what resources you‚Äôll need yet.\npreload\nlets you fetch a stylesheet, font, image, or external script that you expect to use.\npreloadModule\nlets you fetch an ESM module that you expect to use.\npreinit\nlets you fetch and evaluate an external script or fetch and insert a stylesheet.\npreinitModule\nlets you fetch and evaluate an ESM module.\nEntry points\nThe\nreact-dom\npackage provides two additional entry points:\nreact-dom/client\ncontains APIs to render React components on the client (in the browser).\nreact-dom/server\ncontains APIs to render React components on the server.\nRemoved APIs\nThese APIs were removed in React 19:\nfindDOMNode\n: see\nalternatives\n.\nhydrate\n: use\nhydrateRoot\ninstead.\nrender\n: use\ncreateRoot\ninstead.\nunmountComponentAtNode\n: use\nroot.unmount()\ninstead.\nrenderToNodeStream\n: use\nreact-dom/server\nAPIs instead.\nrenderToStaticNodeStream\n: use\nreact-dom/server\nAPIs instead.\nPrevious\n<title>\nNext\ncreatePortal",
    "url": "https://react.dev/reference/react-dom",
    "source": "react",
    "doc_type": "api_reference",
    "scraped_at": 12303.818512
  },
  {
    "title": "React Blog",
    "content": "Blog\nReact Blog\nThis blog is the official source for the updates from the React team. Anything important, including release notes or deprecation notices, will be posted here first.\nYou can also follow the\n@react.dev\naccount on Bluesky, or\n@reactjs\naccount on Twitter, but you won‚Äôt miss anything essential if you only read this blog.\nReact Labs: View Transitions, Activity, and more\nApril 23, 2025\nIn React Labs posts, we write about projects in active research and development. In this post, we‚Äôre sharing two new experimental features that are ready to try today, and sharing other areas we‚Äôre working on now ‚Ä¶\nRead more\nReact Compiler RC\nApril 21, 2025\nWe are releasing the compiler‚Äôs first Release Candidate (RC) today.\nRead more\nSunsetting Create React App\nFebruary 14, 2025\nToday, we‚Äôre deprecating Create React App for new apps, and encouraging existing apps to migrate to a framework, or to migrate to a build tool like Vite, Parcel, or RSBuild. We‚Äôre also providing docs for when a framework isn‚Äôt a good fit for your project, you want to build your own framework, or you just want to learn how React works by building a React app from scratch ‚Ä¶\nRead more\nReact v19\nDecember 5, 2024\nIn the React 19 Upgrade Guide, we shared step-by-step instructions for upgrading your app to React 19. In this post, we‚Äôll give an overview of the new features in React 19, and how you can adopt them ‚Ä¶\nRead more\nReact Compiler Beta Release\nOctober 21, 2024\nWe announced an experimental release of React Compiler at React Conf 2024. We‚Äôve made a lot of progress since then, and in this post we want to share what‚Äôs next for React Compiler ‚Ä¶\nRead more\nReact Conf 2024 Recap\nMay 22, 2024\nLast week we hosted React Conf 2024, a two-day conference in Henderson, Nevada where 700+ attendees gathered in-person to discuss the latest in UI engineering. This was our first in-person conference since 2019, and we were thrilled to be able to bring the community together again ‚Ä¶\nRead more\nReact 19 Upgrade Guide\nApril 25, 2024\nThe improvements added to React 19 require some breaking changes, but we‚Äôve worked to make the upgrade as smooth as possible, and we don‚Äôt expect the changes to impact most apps. In this post, we will guide you through the steps for upgrading libraries to React 19 ‚Ä¶\nRead more\nReact Labs: What We've Been Working On ‚Äì February 2024\nFebruary 15, 2024\nIn React Labs posts, we write about projects in active research and development. Since our last update, we‚Äôve made significant progress on React Compiler, new features, and React 19, and we‚Äôd like to share what we learned.\nRead more\nReact Canaries: Incremental Feature Rollout Outside Meta\nMay 3, 2023\nTraditionally, new React features used to only be available at Meta first, and land in the open source releases later. We‚Äôd like to offer the React community an option to adopt individual new features as soon as their design is close to final‚Äîsimilar to how Meta uses React internally. We are introducing a new officially supported Canary release channel. It lets curated setups like frameworks decouple adoption of individual React features from the React release schedule.\nRead more\nReact Labs: What We've Been Working On ‚Äì March 2023\nMarch 22, 2023\nIn React Labs posts, we write about projects in active research and development. Since our last update, we‚Äôve made significant progress on React Server Components, Asset Loading, Optimizing Compiler, Offscreen Rendering, and Transition Tracing, and we‚Äôd like to share what we learned.\nRead more\nIntroducing react.dev\nMarch 16, 2023\nToday we are thrilled to launch react.dev, the new home for React and its documentation. In this post, we would like to give you a tour of the new site.\nRead more\nReact Labs: What We've Been Working On ‚Äì June 2022\nJune 15, 2022\nReact 18 was years in the making, and with it brought valuable lessons for the React team. Its release was the result of many years of research and exploring many paths. Some of those paths were successful; many more were dead-ends that led to new insights. One lesson we‚Äôve learned is that it‚Äôs frustrating for the community to wait for new features without having insight into these paths that we‚Äôre exploring‚Ä¶\nRead more\nReact v18.0\nMarch 29, 2022\nReact 18 is now available on npm! In our last post, we shared step-by-step instructions for upgrading your app to React 18. In this post, we‚Äôll give an overview of what‚Äôs new in React 18, and what it means for the future‚Ä¶\nRead more\nHow to Upgrade to React 18\nMarch 8, 2022\nAs we shared in the release post, React 18 introduces features powered by our new concurrent renderer, with a gradual adoption strategy for existing applications. In this post, we will guide you through the steps for upgrading to React 18‚Ä¶\nRead more\nReact Conf 2021 Recap\nDecember 17, 2021\nLast week we hosted our 6th React Conf.  In previous years, we‚Äôve used the React Conf stage to deliver industry changing announcements such as React Native and React Hooks. This year, we shared our multi-platform vision for React, starting with the release of React 18 and gradual adoption of concurrent features‚Ä¶\nRead more\nThe Plan for React 18\nJune 8, 2021\nThe React team is excited to share a few updates:\nWe‚Äôve started work on the React 18 release, which will be our next major version.\nWe‚Äôve created a Working Group to prepare the community for gradual adoption of new features in React 18.\nWe‚Äôve published a React 18 Alpha so that library authors can try it and provide feedback‚Ä¶\nRead more\nIntroducing Zero-Bundle-Size React Server Components\nDecember 21, 2020\n2020 has been a long year. As it comes to an end we wanted to share a special Holiday Update on our research into zero-bundle-size React Server Components. To introduce React Server Components, we have prepared a talk and a demo. If you want, you can check them out during the holidays, or later when work picks back up in the new year‚Ä¶\nRead more\nAll release notes\nNot every React release deserves its own blog post, but you can find a detailed changelog for every release in the\nCHANGELOG.md\nfile in the React repository, as well as on the\nReleases\npage.\nOlder posts\nSee the\nolder posts.",
    "url": "https://react.dev/blog",
    "source": "react",
    "doc_type": "example",
    "scraped_at": 12303.9070572
  },
  {
    "title": "Quick Start",
    "content": "Learn React\nQuick Start\nWelcome to the React documentation! This page will give you an introduction to 80% of the React concepts that you will use on a daily basis.\nYou will learn\nHow to create and nest components\nHow to add markup and styles\nHow to display data\nHow to render conditions and lists\nHow to respond to events and update the screen\nHow to share data between components\nCreating and nesting components\nReact apps are made out of\ncomponents\n. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page.\nReact components are JavaScript functions that return markup:\nfunction\nMyButton\n(\n)\n{\nreturn\n(\n<\nbutton\n>\nI'm a button\n</\nbutton\n>\n)\n;\n}\nNow that you‚Äôve declared\nMyButton\n, you can nest it into another component:\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nreturn\n(\n<\ndiv\n>\n<\nh1\n>\nWelcome to my app\n</\nh1\n>\n<\nMyButton\n/>\n</\ndiv\n>\n)\n;\n}\nNotice that\n<MyButton />\nstarts with a capital letter. That‚Äôs how you know it‚Äôs a React component. React component names must always start with a capital letter, while HTML tags must be lowercase.\nHave a look at the result:\nApp.js\nApp.js\nReset\nFork\nfunction\nMyButton\n(\n)\n{\nreturn\n(\n<\nbutton\n>\nI'm a button\n</\nbutton\n>\n)\n;\n}\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nreturn\n(\n<\ndiv\n>\n<\nh1\n>\nWelcome to my app\n</\nh1\n>\n<\nMyButton\n/>\n</\ndiv\n>\n)\n;\n}\nShow more\nThe\nexport default\nkeywords specify the main component in the file. If you‚Äôre not familiar with some piece of JavaScript syntax,\nMDN\nand\njavascript.info\nhave great references.\nWriting markup with JSX\nThe markup syntax you‚Äôve seen above is called\nJSX\n. It is optional, but most React projects use JSX for its convenience. All of the\ntools we recommend for local development\nsupport JSX out of the box.\nJSX is stricter than HTML. You have to close tags like\n<br />\n. Your component also can‚Äôt return multiple JSX tags. You have to wrap them into a shared parent, like a\n<div>...</div>\nor an empty\n<>...</>\nwrapper:\nfunction\nAboutPage\n(\n)\n{\nreturn\n(\n<\n>\n<\nh1\n>\nAbout\n</\nh1\n>\n<\np\n>\nHello there.\n<\nbr\n/>\nHow do you do?\n</\np\n>\n</\n>\n)\n;\n}\nIf you have a lot of HTML to port to JSX, you can use an\nonline converter.\nAdding styles\nIn React, you specify a CSS class with\nclassName\n. It works the same way as the HTML\nclass\nattribute:\n<\nimg\nclassName\n=\n\"avatar\"\n/>\nThen you write the CSS rules for it in a separate CSS file:\n/* In your CSS */\n.avatar\n{\nborder-radius\n:\n50\n%\n;\n}\nReact does not prescribe how you add CSS files. In the simplest case, you‚Äôll add a\n<link>\ntag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.\nDisplaying data\nJSX lets you put markup into JavaScript. Curly braces let you ‚Äúescape back‚Äù into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display\nuser.name\n:\nreturn\n(\n<\nh1\n>\n{\nuser\n.\nname\n}\n</\nh1\n>\n)\n;\nYou can also ‚Äúescape into JavaScript‚Äù from JSX attributes, but you have to use curly braces\ninstead of\nquotes. For example,\nclassName=\"avatar\"\npasses the\n\"avatar\"\nstring as the CSS class, but\nsrc={user.imageUrl}\nreads the JavaScript\nuser.imageUrl\nvariable value, and then passes that value as the\nsrc\nattribute:\nreturn\n(\n<\nimg\nclassName\n=\n\"avatar\"\nsrc\n=\n{\nuser\n.\nimageUrl\n}\n/>\n)\n;\nYou can put more complex expressions inside the JSX curly braces too, for example,\nstring concatenation\n:\nApp.js\nApp.js\nReset\nFork\nconst\nuser\n=\n{\nname\n:\n'Hedy Lamarr'\n,\nimageUrl\n:\n'https://i.imgur.com/yXOvdOSs.jpg'\n,\nimageSize\n:\n90\n,\n}\n;\nexport\ndefault\nfunction\nProfile\n(\n)\n{\nreturn\n(\n<\n>\n<\nh1\n>\n{\nuser\n.\nname\n}\n</\nh1\n>\n<\nimg\nclassName\n=\n\"avatar\"\nsrc\n=\n{\nuser\n.\nimageUrl\n}\nalt\n=\n{\n'Photo of '\n+\nuser\n.\nname\n}\nstyle\n=\n{\n{\nwidth\n:\nuser\n.\nimageSize\n,\nheight\n:\nuser\n.\nimageSize\n}\n}\n/>\n</\n>\n)\n;\n}\nShow more\nIn the above example,\nstyle={{}}\nis not a special syntax, but a regular\n{}\nobject inside the\nstyle={ }\nJSX curly braces. You can use the\nstyle\nattribute when your styles depend on JavaScript variables.\nConditional rendering\nIn React, there is no special syntax for writing conditions. Instead, you‚Äôll use the same techniques as you use when writing regular JavaScript code. For example, you can use an\nif\nstatement to conditionally include JSX:\nlet\ncontent\n;\nif\n(\nisLoggedIn\n)\n{\ncontent\n=\n<\nAdminPanel\n/>\n;\n}\nelse\n{\ncontent\n=\n<\nLoginForm\n/>\n;\n}\nreturn\n(\n<\ndiv\n>\n{\ncontent\n}\n</\ndiv\n>\n)\n;\nIf you prefer more compact code, you can use the\nconditional\n?\noperator.\nUnlike\nif\n, it works inside JSX:\n<\ndiv\n>\n{\nisLoggedIn\n?\n(\n<\nAdminPanel\n/>\n)\n:\n(\n<\nLoginForm\n/>\n)\n}\n</\ndiv\n>\nWhen you don‚Äôt need the\nelse\nbranch, you can also use a shorter\nlogical\n&&\nsyntax\n:\n<\ndiv\n>\n{\nisLoggedIn\n&&\n<\nAdminPanel\n/>\n}\n</\ndiv\n>\nAll of these approaches also work for conditionally specifying attributes. If you‚Äôre unfamiliar with some of this JavaScript syntax, you can start by always using\nif...else\n.\nRendering lists\nYou will rely on JavaScript features like\nfor\nloop\nand the\narray\nmap()\nfunction\nto render lists of components.\nFor example, let‚Äôs say you have an array of products:\nconst\nproducts\n=\n[\n{\ntitle\n:\n'Cabbage'\n,\nid\n:\n1\n}\n,\n{\ntitle\n:\n'Garlic'\n,\nid\n:\n2\n}\n,\n{\ntitle\n:\n'Apple'\n,\nid\n:\n3\n}\n,\n]\n;\nInside your component, use the\nmap()\nfunction to transform an array of products into an array of\n<li>\nitems:\nconst\nlistItems\n=\nproducts\n.\nmap\n(\nproduct\n=>\n<\nli\nkey\n=\n{\nproduct\n.\nid\n}\n>\n{\nproduct\n.\ntitle\n}\n</\nli\n>\n)\n;\nreturn\n(\n<\nul\n>\n{\nlistItems\n}\n</\nul\n>\n)\n;\nNotice how\n<li>\nhas a\nkey\nattribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.\nApp.js\nApp.js\nReset\nFork\nconst\nproducts\n=\n[\n{\ntitle\n:\n'Cabbage'\n,\nisFruit\n:\nfalse\n,\nid\n:\n1\n}\n,\n{\ntitle\n:\n'Garlic'\n,\nisFruit\n:\nfalse\n,\nid\n:\n2\n}\n,\n{\ntitle\n:\n'Apple'\n,\nisFruit\n:\ntrue\n,\nid\n:\n3\n}\n,\n]\n;\nexport\ndefault\nfunction\nShoppingList\n(\n)\n{\nconst\nlistItems\n=\nproducts\n.\nmap\n(\nproduct\n=>\n<\nli\nkey\n=\n{\nproduct\n.\nid\n}\nstyle\n=\n{\n{\ncolor\n:\nproduct\n.\nisFruit\n?\n'magenta'\n:\n'darkgreen'\n}\n}\n>\n{\nproduct\n.\ntitle\n}\n</\nli\n>\n)\n;\nreturn\n(\n<\nul\n>\n{\nlistItems\n}\n</\nul\n>\n)\n;\n}\nShow more\nResponding to events\nYou can respond to events by declaring\nevent handler\nfunctions inside your components:\nfunction\nMyButton\n(\n)\n{\nfunction\nhandleClick\n(\n)\n{\nalert\n(\n'You clicked me!'\n)\n;\n}\nreturn\n(\n<\nbutton\nonClick\n=\n{\nhandleClick\n}\n>\nClick me\n</\nbutton\n>\n)\n;\n}\nNotice how\nonClick={handleClick}\nhas no parentheses at the end! Do not\ncall\nthe event handler function: you only need to\npass it down\n. React will call your event handler when the user clicks the button.\nUpdating the screen\nOften, you‚Äôll want your component to ‚Äúremember‚Äù some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add\nstate\nto your component.\nFirst, import\nuseState\nfrom React:\nimport\n{\nuseState\n}\nfrom\n'react'\n;\nNow you can declare a\nstate variable\ninside your component:\nfunction\nMyButton\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\n// ...\nYou‚Äôll get two things from\nuseState\n: the current state (\ncount\n), and the function that lets you update it (\nsetCount\n). You can give them any names, but the convention is to write\n[something, setSomething]\n.\nThe first time the button is displayed,\ncount\nwill be\n0\nbecause you passed\n0\nto\nuseState()\n. When you want to change state, call\nsetCount()\nand pass the new value to it. Clicking this button will increment the counter:\nfunction\nMyButton\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\nfunction\nhandleClick\n(\n)\n{\nsetCount\n(\ncount\n+\n1\n)\n;\n}\nreturn\n(\n<\nbutton\nonClick\n=\n{\nhandleClick\n}\n>\nClicked\n{\ncount\n}\ntimes\n</\nbutton\n>\n)\n;\n}\nReact will call your component function again. This time,\ncount\nwill be\n1\n. Then it will be\n2\n. And so on.\nIf you render the same component multiple times, each will get its own state. Click each button separately:\nApp.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n}\nfrom\n'react'\n;\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nreturn\n(\n<\ndiv\n>\n<\nh1\n>\nCounters that update separately\n</\nh1\n>\n<\nMyButton\n/>\n<\nMyButton\n/>\n</\ndiv\n>\n)\n;\n}\nfunction\nMyButton\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\nfunction\nhandleClick\n(\n)\n{\nsetCount\n(\ncount\n+\n1\n)\n;\n}\nreturn\n(\n<\nbutton\nonClick\n=\n{\nhandleClick\n}\n>\nClicked\n{\ncount\n}\ntimes\n</\nbutton\n>\n)\n;\n}\nShow more\nNotice how each button ‚Äúremembers‚Äù its own\ncount\nstate and doesn‚Äôt affect other buttons.\nUsing Hooks\nFunctions starting with\nuse\nare called\nHooks\n.\nuseState\nis a built-in Hook provided by React. You can find other built-in Hooks in the\nAPI reference.\nYou can also write your own Hooks by combining the existing ones.\nHooks are more restrictive than other functions. You can only call Hooks\nat the top\nof your components (or other Hooks). If you want to use\nuseState\nin a condition or a loop, extract a new component and put it there.\nSharing data between components\nIn the previous example, each\nMyButton\nhad its own independent\ncount\n, and when each button was clicked, only the\ncount\nfor the button clicked changed:\nInitially, each\nMyButton\n‚Äôs\ncount\nstate is\n0\nThe first\nMyButton\nupdates its\ncount\nto\n1\nHowever, often you‚Äôll need components to\nshare data and always update together\n.\nTo make both\nMyButton\ncomponents display the same\ncount\nand update together, you need to move the state from the individual buttons ‚Äúupwards‚Äù to the closest component containing all of them.\nIn this example, it is\nMyApp\n:\nInitially,\nMyApp\n‚Äôs\ncount\nstate is\n0\nand is passed down to both children\nOn click,\nMyApp\nupdates its\ncount\nstate to\n1\nand passes it down to both children\nNow when you click either button, the\ncount\nin\nMyApp\nwill change, which will change both of the counts in\nMyButton\n. Here‚Äôs how you can express this in code.\nFirst,\nmove the state up\nfrom\nMyButton\ninto\nMyApp\n:\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\nfunction\nhandleClick\n(\n)\n{\nsetCount\n(\ncount\n+\n1\n)\n;\n}\nreturn\n(\n<\ndiv\n>\n<\nh1\n>\nCounters that update separately\n</\nh1\n>\n<\nMyButton\n/>\n<\nMyButton\n/>\n</\ndiv\n>\n)\n;\n}\nfunction\nMyButton\n(\n)\n{\n// ... we're moving code from here ...\n}\nThen,\npass the state down\nfrom\nMyApp\nto each\nMyButton\n, together with the shared click handler. You can pass information to\nMyButton\nusing the JSX curly braces, just like you previously did with built-in tags like\n<img>\n:\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\nfunction\nhandleClick\n(\n)\n{\nsetCount\n(\ncount\n+\n1\n)\n;\n}\nreturn\n(\n<\ndiv\n>\n<\nh1\n>\nCounters that update together\n</\nh1\n>\n<\nMyButton\ncount\n=\n{\ncount\n}\nonClick\n=\n{\nhandleClick\n}\n/>\n<\nMyButton\ncount\n=\n{\ncount\n}\nonClick\n=\n{\nhandleClick\n}\n/>\n</\ndiv\n>\n)\n;\n}\nThe information you pass down like this is called\nprops\n. Now the\nMyApp\ncomponent contains the\ncount\nstate and the\nhandleClick\nevent handler, and\npasses both of them down as props\nto each of the buttons.\nFinally, change\nMyButton\nto\nread\nthe props you have passed from its parent component:\nfunction\nMyButton\n(\n{\ncount\n,\nonClick\n}\n)\n{\nreturn\n(\n<\nbutton\nonClick\n=\n{\nonClick\n}\n>\nClicked\n{\ncount\n}\ntimes\n</\nbutton\n>\n)\n;\n}\nWhen you click the button, the\nonClick\nhandler fires. Each button‚Äôs\nonClick\nprop was set to the\nhandleClick\nfunction inside\nMyApp\n, so the code inside of it runs. That code calls\nsetCount(count + 1)\n, incrementing the\ncount\nstate variable. The new\ncount\nvalue is passed as a prop to each button, so they all show the new value. This is called ‚Äúlifting state up‚Äù. By moving state up, you‚Äôve shared it between components.\nApp.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n}\nfrom\n'react'\n;\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\nfunction\nhandleClick\n(\n)\n{\nsetCount\n(\ncount\n+\n1\n)\n;\n}\nreturn\n(\n<\ndiv\n>\n<\nh1\n>\nCounters that update together\n</\nh1\n>\n<\nMyButton\ncount\n=\n{\ncount\n}\nonClick\n=\n{\nhandleClick\n}\n/>\n<\nMyButton\ncount\n=\n{\ncount\n}\nonClick\n=\n{\nhandleClick\n}\n/>\n</\ndiv\n>\n)\n;\n}\nfunction\nMyButton\n(\n{\ncount\n,\nonClick\n}\n)\n{\nreturn\n(\n<\nbutton\nonClick\n=\n{\nonClick\n}\n>\nClicked\n{\ncount\n}\ntimes\n</\nbutton\n>\n)\n;\n}\nShow more\nNext Steps\nBy now, you know the basics of how to write React code!\nCheck out the\nTutorial\nto put them into practice and build your first mini-app with React.\nNext\nTutorial: Tic-Tac-Toe",
    "url": "https://react.dev/learn",
    "source": "react",
    "doc_type": "example",
    "scraped_at": 12304.1502064
  },
  {
    "title": "React Reference Overview",
    "content": "API Reference\nReact Reference Overview\nThis section provides detailed reference documentation for working with React. For an introduction to React, please visit the\nLearn\nsection.\nThe React reference documentation is broken down into functional subsections:\nReact\nProgrammatic React features:\nHooks\n- Use different React features from your components.\nComponents\n- Built-in components that you can use in your JSX.\nAPIs\n- APIs that are useful for defining components.\nDirectives\n- Provide instructions to bundlers compatible with React Server Components.\nReact DOM\nReact-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:\nHooks\n- Hooks for web applications which run in the browser DOM environment.\nComponents\n- React supports all of the browser built-in HTML and SVG components.\nAPIs\n- The\nreact-dom\npackage contains methods supported only in web applications.\nClient APIs\n- The\nreact-dom/client\nAPIs let you render React components on the client (in the browser).\nServer APIs\n- The\nreact-dom/server\nAPIs let you render React components to HTML on the server.\nReact Compiler\nThe React Compiler is a build-time optimization tool that automatically memoizes your React components and values:\nConfiguration\n- Configuration options for React Compiler.\nDirectives\n- Function-level directives to control compilation.\nCompiling Libraries\n- Guide for shipping pre-compiled library code.\nRules of React\nReact has idioms ‚Äî or rules ‚Äî for how to express patterns in a way that is easy to understand and yields high-quality applications:\nComponents and Hooks must be pure\n‚Äì Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.\nReact calls Components and Hooks\n‚Äì React is responsible for rendering components and hooks when necessary to optimize the user experience.\nRules of Hooks\n‚Äì Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.\nLegacy APIs\nLegacy APIs\n- Exported from the\nreact\npackage, but not recommended for use in newly written code.\nNext\nHooks",
    "url": "https://react.dev/reference/react",
    "source": "react",
    "doc_type": "api_reference",
    "scraped_at": 12304.4144967
  },
  {
    "title": "useEffect",
    "content": "API Reference\nHooks\nuseEffect\nuseEffect\nis a React Hook that lets you\nsynchronize a component with an external system.\nuseEffect\n(\nsetup\n,\ndependencies\n?\n)\nReference\nuseEffect(setup, dependencies?)\nUsage\nConnecting to an external system\nWrapping Effects in custom Hooks\nControlling a non-React widget\nFetching data with Effects\nSpecifying reactive dependencies\nUpdating state based on previous state from an Effect\nRemoving unnecessary object dependencies\nRemoving unnecessary function dependencies\nReading the latest props and state from an Effect\nDisplaying different content on the server and the client\nTroubleshooting\nMy Effect runs twice when the component mounts\nMy Effect runs after every re-render\nMy Effect keeps re-running in an infinite cycle\nMy cleanup logic runs even though my component didn‚Äôt unmount\nMy Effect does something visual, and I see a flicker before it runs\nReference\nuseEffect(setup, dependencies?)\nCall\nuseEffect\nat the top level of your component to declare an Effect:\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nserverUrl\n,\nroomId\n]\n)\n;\n// ...\n}\nSee more examples below.\nParameters\nsetup\n: The function with your Effect‚Äôs logic. Your setup function may also optionally return a\ncleanup\nfunction. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.\noptional\ndependencies\n: The list of all reactive values referenced inside of the\nsetup\ncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is\nconfigured for React\n, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like\n[dep1, dep2, dep3]\n. React will compare each dependency with its previous value using the\nObject.is\ncomparison. If you omit this argument, your Effect will re-run after every re-render of the component.\nSee the difference between passing an array of dependencies, an empty array, and no dependencies at all.\nReturns\nuseEffect\nreturns\nundefined\n.\nCaveats\nuseEffect\nis a Hook, so you can only call it\nat the top level of your component\nor your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\nIf you‚Äôre\nnot trying to synchronize with some external system,\nyou probably don‚Äôt need an Effect.\nWhen Strict Mode is on, React will\nrun one extra development-only setup+cleanup cycle\nbefore the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,\nimplement the cleanup function.\nIf some of your dependencies are objects or functions defined inside the component, there is a risk that they will\ncause the Effect to re-run more often than needed.\nTo fix this, remove unnecessary\nobject\nand\nfunction\ndependencies. You can also\nextract state updates\nand\nnon-reactive logic\noutside of your Effect.\nIf your Effect wasn‚Äôt caused by an interaction (like a click), React will generally let the browser\npaint the updated screen first before running your Effect.\nIf your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace\nuseEffect\nwith\nuseLayoutEffect\n.\nIf your Effect is caused by an interaction (like a click),\nReact may run your Effect before the browser paints the updated screen\n. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an\nalert()\n, you can use\nsetTimeout\n. See\nreactwg/react-18/128\nfor more information.\nEven if your Effect was caused by an interaction (like a click),\nReact may allow the browser to repaint the screen before processing the state updates inside your Effect.\nUsually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace\nuseEffect\nwith\nuseLayoutEffect\n.\nEffects\nonly run on the client.\nThey don‚Äôt run during server rendering.\nUsage\nConnecting to an external system\nSome components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren‚Äôt controlled by React, so they are called\nexternal.\nTo\nconnect your component to some external system,\ncall\nuseEffect\nat the top level of your component:\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn\n(\n)\n=>\n{\nconnection.disconnect();\n}\n;\n}\n,\n[serverUrl, roomId]\n)\n;\n// ...\n}\nYou need to pass two arguments to\nuseEffect\n:\nA\nsetup function\nwith\nsetup code\nthat connects to that system.\nIt should return a\ncleanup function\nwith\ncleanup code\nthat disconnects from that system.\nA\nlist of dependencies\nincluding every value from your component used inside of those functions.\nReact calls your setup and cleanup functions whenever it‚Äôs necessary, which may happen multiple times:\nYour\nsetup code\nruns when your component is added to the page\n(mounts)\n.\nAfter every re-render of your component where the\ndependencies\nhave changed:\nFirst, your\ncleanup code\nruns with the old props and state.\nThen, your\nsetup code\nruns with the new props and state.\nYour\ncleanup code\nruns one final time after your component is removed from the page\n(unmounts).\nLet‚Äôs illustrate this sequence for the example above.\nWhen the\nChatRoom\ncomponent above gets added to the page, it will connect to the chat room with the initial\nserverUrl\nand\nroomId\n. If either\nserverUrl\nor\nroomId\nchange as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will\ndisconnect from the previous room, and connect to the next one.\nWhen the\nChatRoom\ncomponent is removed from the page, your Effect will disconnect one last time.\nTo\nhelp you find bugs,\nin development React runs\nsetup\nand\ncleanup\none extra time before the\nsetup\n.\nThis is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a\nsetup\n‚Üí\ncleanup\n‚Üí\nsetup\nsequence (as in development).\nSee common solutions.\nTry to\nwrite every Effect as an independent process\nand\nthink about a single setup/cleanup cycle at a time.\nIt shouldn‚Äôt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly ‚Äúmirrors‚Äù the setup logic, your Effect is resilient to running setup and cleanup as often as needed.\nNote\nAn Effect lets you\nkeep your component synchronized\nwith some external system (like a chat service). Here,\nexternal system\nmeans any piece of code that‚Äôs not controlled by React, such as:\nA timer managed with\nsetInterval()\nand\nclearInterval()\n.\nAn event subscription using\nwindow.addEventListener()\nand\nwindow.removeEventListener()\n.\nA third-party animation library with an API like\nanimation.start()\nand\nanimation.reset()\n.\nIf you‚Äôre not connecting to any external system,\nyou probably don‚Äôt need an Effect.\nExamples of connecting to an external system\n1\n.\nConnecting to a chat server\n2\n.\nListening to a global browser event\n3\n.\nTriggering an animation\n4\n.\nControlling a modal dialog\n5\n.\nTracking element visibility\nExample\n1\nof\n5\n:\nConnecting to a chat server\nIn this example, the\nChatRoom\ncomponent uses an Effect to stay connected to an external system defined in\nchat.js\n. Press ‚ÄúOpen chat‚Äù to make the\nChatRoom\ncomponent appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as\nexplained here.\nTry changing the\nroomId\nand\nserverUrl\nusing the dropdown and the input, and see how the Effect re-connects to the chat. Press ‚ÄúClose chat‚Äù to see the Effect disconnect one last time.\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n,\nserverUrl\n]\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nServer URL:\n{\n' '\n}\n<\ninput\nvalue\n=\n{\nserverUrl\n}\nonChange\n=\n{\ne\n=>\nsetServerUrl\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nconst\n[\nshow\n,\nsetShow\n]\n=\nuseState\n(\nfalse\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nbutton\nonClick\n=\n{\n(\n)\n=>\nsetShow\n(\n!\nshow\n)\n}\n>\n{\nshow\n?\n'Close chat'\n:\n'Open chat'\n}\n</\nbutton\n>\n{\nshow\n&&\n<\nhr\n/>\n}\n{\nshow\n&&\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n}\n</\n>\n)\n;\n}\nShow more\nNext\nExample\nWrapping Effects in custom Hooks\nEffects are an\n‚Äúescape hatch‚Äù:\nyou use them when you need to ‚Äústep outside React‚Äù and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it‚Äôs usually a sign that you need to extract some\ncustom Hooks\nfor common behaviors your components rely on.\nFor example, this\nuseChatRoom\ncustom Hook ‚Äúhides‚Äù the logic of your Effect behind a more declarative API:\nfunction\nuseChatRoom\n(\n{\nserverUrl\n,\nroomId\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\noptions\n=\n{\nserverUrl\n:\nserverUrl\n,\nroomId\n:\nroomId\n}\n;\nconst\nconnection\n=\ncreateConnection\n(\noptions\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\nroomId\n,\nserverUrl\n]\n)\n;\n}\nThen you can use it from any component like this:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nuseChatRoom\n(\n{\nroomId\n:\nroomId\n,\nserverUrl\n:\nserverUrl\n}\n)\n;\n// ...\nThere are also many excellent custom Hooks for every purpose available in the React ecosystem.\nLearn more about wrapping Effects in custom Hooks.\nExamples of wrapping Effects in custom Hooks\n1\n.\nCustom\nuseChatRoom\nHook\n2\n.\nCustom\nuseWindowListener\nHook\n3\n.\nCustom\nuseIntersectionObserver\nHook\nExample\n1\nof\n3\n:\nCustom\nuseChatRoom\nHook\nThis example is identical to one of the\nearlier examples,\nbut the logic is extracted to a custom Hook.\nApp.js\nuseChatRoom.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n}\nfrom\n'react'\n;\nimport\n{\nuseChatRoom\n}\nfrom\n'./useChatRoom.js'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nuseChatRoom\n(\n{\nroomId\n:\nroomId\n,\nserverUrl\n:\nserverUrl\n}\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nServer URL:\n{\n' '\n}\n<\ninput\nvalue\n=\n{\nserverUrl\n}\nonChange\n=\n{\ne\n=>\nsetServerUrl\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nconst\n[\nshow\n,\nsetShow\n]\n=\nuseState\n(\nfalse\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nbutton\nonClick\n=\n{\n(\n)\n=>\nsetShow\n(\n!\nshow\n)\n}\n>\n{\nshow\n?\n'Close chat'\n:\n'Open chat'\n}\n</\nbutton\n>\n{\nshow\n&&\n<\nhr\n/>\n}\n{\nshow\n&&\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n}\n</\n>\n)\n;\n}\nShow more\nNext\nExample\nControlling a non-React widget\nSometimes, you want to keep an external system synchronized to some prop or state of your component.\nFor example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a\nMapWidget\nclass defined in\nmap-widget.js\n. When you change the\nzoomLevel\nprop of the\nMap\ncomponent, the Effect calls the\nsetZoom()\non the class instance to keep it synchronized:\nApp.js\nMap.js\nmap-widget.js\nMap.js\nReset\nFork\nimport\n{\nuseRef\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\nMapWidget\n}\nfrom\n'./map-widget.js'\n;\nexport\ndefault\nfunction\nMap\n(\n{\nzoomLevel\n}\n)\n{\nconst\ncontainerRef\n=\nuseRef\n(\nnull\n)\n;\nconst\nmapRef\n=\nuseRef\n(\nnull\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nif\n(\nmapRef\n.\ncurrent\n===\nnull\n)\n{\nmapRef\n.\ncurrent\n=\nnew\nMapWidget\n(\ncontainerRef\n.\ncurrent\n)\n;\n}\nconst\nmap\n=\nmapRef\n.\ncurrent\n;\nmap\n.\nsetZoom\n(\nzoomLevel\n)\n;\n}\n,\n[\nzoomLevel\n]\n)\n;\nreturn\n(\n<\ndiv\nstyle\n=\n{\n{\nwidth\n:\n200\n,\nheight\n:\n200\n}\n}\nref\n=\n{\ncontainerRef\n}\n/>\n)\n;\n}\nShow more\nIn this example, a cleanup function is not needed because the\nMapWidget\nclass manages only the DOM node that was passed to it. After the\nMap\nReact component is removed from the tree, both the DOM node and the\nMapWidget\nclass instance will be automatically garbage-collected by the browser JavaScript engine.\nFetching data with Effects\nYou can use an Effect to fetch data for your component. Note that\nif you use a framework,\nusing your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually.\nIf you want to fetch data from an Effect manually, your code might look like this:\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\nfetchBio\n}\nfrom\n'./api.js'\n;\nexport\ndefault\nfunction\nPage\n(\n)\n{\nconst\n[\nperson\n,\nsetPerson\n]\n=\nuseState\n(\n'Alice'\n)\n;\nconst\n[\nbio\n,\nsetBio\n]\n=\nuseState\n(\nnull\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nlet\nignore\n=\nfalse\n;\nsetBio\n(\nnull\n)\n;\nfetchBio\n(\nperson\n)\n.\nthen\n(\nresult\n=>\n{\nif\n(\n!\nignore\n)\n{\nsetBio\n(\nresult\n)\n;\n}\n}\n)\n;\nreturn\n(\n)\n=>\n{\nignore\n=\ntrue\n;\n}\n;\n}\n,\n[\nperson\n]\n)\n;\n// ...\nNote the\nignore\nvariable which is initialized to\nfalse\n, and is set to\ntrue\nduring cleanup. This ensures\nyour code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù:\nnetwork responses may arrive in a different order than you sent them.\nApp.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\nfetchBio\n}\nfrom\n'./api.js'\n;\nexport\ndefault\nfunction\nPage\n(\n)\n{\nconst\n[\nperson\n,\nsetPerson\n]\n=\nuseState\n(\n'Alice'\n)\n;\nconst\n[\nbio\n,\nsetBio\n]\n=\nuseState\n(\nnull\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nlet\nignore\n=\nfalse\n;\nsetBio\n(\nnull\n)\n;\nfetchBio\n(\nperson\n)\n.\nthen\n(\nresult\n=>\n{\nif\n(\n!\nignore\n)\n{\nsetBio\n(\nresult\n)\n;\n}\n}\n)\n;\nreturn\n(\n)\n=>\n{\nignore\n=\ntrue\n;\n}\n}\n,\n[\nperson\n]\n)\n;\nreturn\n(\n<\n>\n<\nselect\nvalue\n=\n{\nperson\n}\nonChange\n=\n{\ne\n=>\n{\nsetPerson\n(\ne\n.\ntarget\n.\nvalue\n)\n;\n}\n}\n>\n<\noption\nvalue\n=\n\"Alice\"\n>\nAlice\n</\noption\n>\n<\noption\nvalue\n=\n\"Bob\"\n>\nBob\n</\noption\n>\n<\noption\nvalue\n=\n\"Taylor\"\n>\nTaylor\n</\noption\n>\n</\nselect\n>\n<\nhr\n/>\n<\np\n>\n<\ni\n>\n{\nbio\n??\n'Loading...'\n}\n</\ni\n>\n</\np\n>\n</\n>\n)\n;\n}\nShow more\nYou can also rewrite using the\nasync\n/\nawait\nsyntax, but you still need to provide a cleanup function:\nApp.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\nfetchBio\n}\nfrom\n'./api.js'\n;\nexport\ndefault\nfunction\nPage\n(\n)\n{\nconst\n[\nperson\n,\nsetPerson\n]\n=\nuseState\n(\n'Alice'\n)\n;\nconst\n[\nbio\n,\nsetBio\n]\n=\nuseState\n(\nnull\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nasync\nfunction\nstartFetching\n(\n)\n{\nsetBio\n(\nnull\n)\n;\nconst\nresult\n=\nawait\nfetchBio\n(\nperson\n)\n;\nif\n(\n!\nignore\n)\n{\nsetBio\n(\nresult\n)\n;\n}\n}\nlet\nignore\n=\nfalse\n;\nstartFetching\n(\n)\n;\nreturn\n(\n)\n=>\n{\nignore\n=\ntrue\n;\n}\n}\n,\n[\nperson\n]\n)\n;\nreturn\n(\n<\n>\n<\nselect\nvalue\n=\n{\nperson\n}\nonChange\n=\n{\ne\n=>\n{\nsetPerson\n(\ne\n.\ntarget\n.\nvalue\n)\n;\n}\n}\n>\n<\noption\nvalue\n=\n\"Alice\"\n>\nAlice\n</\noption\n>\n<\noption\nvalue\n=\n\"Bob\"\n>\nBob\n</\noption\n>\n<\noption\nvalue\n=\n\"Taylor\"\n>\nTaylor\n</\noption\n>\n</\nselect\n>\n<\nhr\n/>\n<\np\n>\n<\ni\n>\n{\nbio\n??\n'Loading...'\n}\n</\ni\n>\n</\np\n>\n</\n>\n)\n;\n}\nShow more\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later.\nIt‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community.\nDeep Dive\nWhat are good alternatives to data fetching in Effects?\nShow Details\nWriting\nfetch\ncalls inside Effects is a\npopular way to fetch data\n, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\nEffects don‚Äôt run on the server.\nThis means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\nFetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù.\nYou render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\nFetching directly in Effects usually means you don‚Äôt preload or cache data.\nFor example, if the component unmounts and then mounts again, it would have to fetch the data again.\nIt‚Äôs not very ergonomic.\nThere‚Äôs quite a bit of boilerplate code involved when writing\nfetch\ncalls in a way that doesn‚Äôt suffer from bugs like\nrace conditions.\nThis list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\nIf you use a\nframework\n, use its built-in data fetching mechanism.\nModern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.\nOtherwise, consider using or building a client-side cache.\nPopular open source solutions include\nReact Query\n,\nuseSWR\n, and\nReact Router 6.4+.\nYou can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).\nYou can continue fetching data directly in Effects if neither of these approaches suit you.\nSpecifying reactive dependencies\nNotice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect.\nEvery\nreactive value\nused by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\n// This is a reactive value\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\n// This is a reactive value too\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// This Effect reads these reactive values\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\nserverUrl\n,\nroomId\n]\n)\n;\n// ‚úÖ So you must specify them as dependencies of your Effect\n// ...\n}\nIf either\nserverUrl\nor\nroomId\nchange, your Effect will reconnect to the chat using the new values.\nReactive values\ninclude props and all variables and functions declared directly inside of your component.\nSince\nroomId\nand\nserverUrl\nare reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them and\nyour linter is correctly configured for React,\nthe linter will flag this as a mistake you need to fix:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\n]\n)\n;\n// üî¥ React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'\n// ...\n}\nTo remove a dependency, you need to\n‚Äúprove‚Äù to the linter that it\ndoesn‚Äôt need\nto be a dependency.\nFor example, you can move\nserverUrl\nout of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders:\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\n// Not a reactive value anymore\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\nroomId\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nNow that\nserverUrl\nis not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency.\nIf your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty (\n[]\n):\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\n// Not a reactive value anymore\nconst\nroomId\n=\n'music'\n;\n// Not a reactive value anymore\nfunction\nChatRoom\n(\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nAn Effect with empty dependencies\ndoesn‚Äôt re-run when any of your component‚Äôs props or state change.\nPitfall\nIf you have an existing codebase, you might have some Effects that suppress the linter like this:\nuseEffect\n(\n(\n)\n=>\n{\n// ...\n// üî¥ Avoid suppressing the linter like this:\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n}\n,\n[\n]\n)\n;\nWhen dependencies don‚Äôt match the code, there is a high risk of introducing bugs.\nBy suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on.\nInstead, prove they‚Äôre unnecessary.\nExamples of passing reactive dependencies\n1\n.\nPassing a dependency array\n2\n.\nPassing an empty dependency array\n3\n.\nPassing no dependency array at all\nExample\n1\nof\n3\n:\nPassing a dependency array\nIf you specify the dependencies, your Effect runs\nafter the initial render\nand\nafter re-renders with changed dependencies.\nuseEffect\n(\n(\n)\n=>\n{\n// ...\n}\n,\n[\na\n,\nb\n]\n)\n;\n// Runs again if a or b are different\nIn the below example,\nserverUrl\nand\nroomId\nare\nreactive values,\nso they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since\nmessage\nisn‚Äôt used in the Effect (and so it isn‚Äôt a dependency), editing the message doesn‚Äôt re-connect to the chat.\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nconst\n[\nmessage\n,\nsetMessage\n]\n=\nuseState\n(\n''\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nserverUrl\n,\nroomId\n]\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nServer URL:\n{\n' '\n}\n<\ninput\nvalue\n=\n{\nserverUrl\n}\nonChange\n=\n{\ne\n=>\nsetServerUrl\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n<\nlabel\n>\nYour message:\n{\n' '\n}\n<\ninput\nvalue\n=\n{\nmessage\n}\nonChange\n=\n{\ne\n=>\nsetMessage\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nshow\n,\nsetShow\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n<\nbutton\nonClick\n=\n{\n(\n)\n=>\nsetShow\n(\n!\nshow\n)\n}\n>\n{\nshow\n?\n'Close chat'\n:\n'Open chat'\n}\n</\nbutton\n>\n</\nlabel\n>\n{\nshow\n&&\n<\nhr\n/>\n}\n{\nshow\n&&\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n}\n</\n>\n)\n;\n}\nShow more\nNext\nExample\nUpdating state based on previous state from an Effect\nWhen you want to update state based on previous state from an Effect, you might run into a problem:\nfunction\nCounter\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nintervalId\n=\nsetInterval\n(\n(\n)\n=>\n{\nsetCount\n(\ncount\n+\n1\n)\n;\n// You want to increment the counter every second...\n}\n,\n1000\n)\nreturn\n(\n)\n=>\nclearInterval\n(\nintervalId\n)\n;\n}\n,\n[\ncount\n]\n)\n;\n// üö© ... but specifying `count` as a dependency always resets the interval.\n// ...\n}\nSince\ncount\nis a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the\ncount\nchanges. This is not ideal.\nTo fix this,\npass the\nc => c + 1\nstate updater\nto\nsetCount\n:\nApp.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nexport\ndefault\nfunction\nCounter\n(\n)\n{\nconst\n[\ncount\n,\nsetCount\n]\n=\nuseState\n(\n0\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nintervalId\n=\nsetInterval\n(\n(\n)\n=>\n{\nsetCount\n(\nc\n=>\nc\n+\n1\n)\n;\n// ‚úÖ Pass a state updater\n}\n,\n1000\n)\n;\nreturn\n(\n)\n=>\nclearInterval\n(\nintervalId\n)\n;\n}\n,\n[\n]\n)\n;\n// ‚úÖ Now count is not a dependency\nreturn\n<\nh1\n>\n{\ncount\n}\n</\nh1\n>\n;\n}\nNow that you‚Äôre passing\nc => c + 1\ninstead of\ncount + 1\n,\nyour Effect no longer needs to depend on\ncount\n.\nAs a result of this fix, it won‚Äôt need to cleanup and setup the interval again every time the\ncount\nchanges.\nRemoving unnecessary object dependencies\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the\noptions\nobject is\ndifferent for every render:\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nmessage\n,\nsetMessage\n]\n=\nuseState\n(\n''\n)\n;\nconst\noptions\n=\n{\n// üö© This object is created from scratch on every re-render\nserverUrl\n:\nserverUrl\n,\nroomId\n:\nroomId\n}\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\noptions\n)\n;\n// It's used inside the Effect\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\noptions\n]\n)\n;\n// üö© As a result, these dependencies are always different on a re-render\n// ...\nAvoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nmessage\n,\nsetMessage\n]\n=\nuseState\n(\n''\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\noptions\n=\n{\nserverUrl\n:\nserverUrl\n,\nroomId\n:\nroomId\n}\n;\nconst\nconnection\n=\ncreateConnection\n(\noptions\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\nroomId\n]\n)\n;\nreturn\n(\n<\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n<\ninput\nvalue\n=\n{\nmessage\n}\nonChange\n=\n{\ne\n=>\nsetMessage\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nhr\n/>\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n</\n>\n)\n;\n}\nShow more\nNow that you create the\noptions\nobject inside the Effect, the Effect itself only depends on the\nroomId\nstring.\nWith this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string like\nroomId\ndoesn‚Äôt change unless you set it to another value.\nRead more about removing dependencies.\nRemoving unnecessary function dependencies\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the\ncreateOptions\nfunction is\ndifferent for every render:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nmessage\n,\nsetMessage\n]\n=\nuseState\n(\n''\n)\n;\nfunction\ncreateOptions\n(\n)\n{\n// üö© This function is created from scratch on every re-render\nreturn\n{\nserverUrl\n:\nserverUrl\n,\nroomId\n:\nroomId\n}\n;\n}\nuseEffect\n(\n(\n)\n=>\n{\nconst\noptions\n=\ncreateOptions\n(\n)\n;\n// It's used inside the Effect\nconst\nconnection\n=\ncreateConnection\n(\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\ncreateOptions\n]\n)\n;\n// üö© As a result, these dependencies are always different on a re-render\n// ...\nBy itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.\nAvoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nmessage\n,\nsetMessage\n]\n=\nuseState\n(\n''\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nfunction\ncreateOptions\n(\n)\n{\nreturn\n{\nserverUrl\n:\nserverUrl\n,\nroomId\n:\nroomId\n}\n;\n}\nconst\noptions\n=\ncreateOptions\n(\n)\n;\nconst\nconnection\n=\ncreateConnection\n(\noptions\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\nroomId\n]\n)\n;\nreturn\n(\n<\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n<\ninput\nvalue\n=\n{\nmessage\n}\nonChange\n=\n{\ne\n=>\nsetMessage\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nhr\n/>\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n</\n>\n)\n;\n}\nShow more\nNow that you define the\ncreateOptions\nfunction inside the Effect, the Effect itself only depends on the\nroomId\nstring. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike a function which gets re-created, a string like\nroomId\ndoesn‚Äôt change unless you set it to another value.\nRead more about removing dependencies.\nReading the latest props and state from an Effect\nUnder Construction\nThis section describes an\nexperimental API that has not yet been released\nin a stable version of React.\nBy default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect ‚Äúreacts‚Äù to every change of that value. For most dependencies, that‚Äôs the behavior you want.\nHowever, sometimes you‚Äôll want to read the\nlatest\nprops and state from an Effect without ‚Äúreacting‚Äù to them.\nFor example, imagine you want to log the number of the items in the shopping cart for every page visit:\nfunction\nPage\n(\n{\nurl\n,\nshoppingCart\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nlogVisit\n(\nurl\n,\nshoppingCart\n.\nlength\n)\n;\n}\n,\n[\nurl\n,\nshoppingCart\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nWhat if you want to log a new page visit after every\nurl\nchange, but\nnot\nif only the\nshoppingCart\nchanges?\nYou can‚Äôt exclude\nshoppingCart\nfrom dependencies without breaking the\nreactivity rules.\nHowever, you can express that you\ndon‚Äôt want\na piece of code to ‚Äúreact‚Äù to changes even though it is called from inside an Effect.\nDeclare an\nEffect Event\nwith the\nuseEffectEvent\nHook, and move the code reading\nshoppingCart\ninside of it:\nfunction\nPage\n(\n{\nurl\n,\nshoppingCart\n}\n)\n{\nconst\nonVisit\n=\nuseEffectEvent\n(\nvisitedUrl\n=>\n{\nlogVisit\n(\nvisitedUrl\n,\nshoppingCart\n.\nlength\n)\n}\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nonVisit\n(\nurl\n)\n;\n}\n,\n[\nurl\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nEffect Events are not reactive and must always be omitted from dependencies of your Effect.\nThis is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading\nshoppingCart\ninside of\nonVisit\n, you ensure that\nshoppingCart\nwon‚Äôt re-run your Effect.\nRead more about how Effect Events let you separate reactive and non-reactive code.\nDisplaying different content on the server and the client\nIf your app uses server rendering (either\ndirectly\nor via a\nframework\n), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for\nhydration\nto work, your initial render output must be identical on the client and the server.\nIn rare cases, you might need to display different content on the client. For example, if your app reads some data from\nlocalStorage\n, it can‚Äôt possibly do that on the server. Here is how you could implement this:\nfunction\nMyComponent\n(\n)\n{\nconst\n[\ndidMount\n,\nsetDidMount\n]\n=\nuseState\n(\nfalse\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nsetDidMount\n(\ntrue\n)\n;\n}\n,\n[\n]\n)\n;\nif\n(\ndidMount\n)\n{\n// ... return client-only JSX ...\n}\nelse\n{\n// ... return initial JSX ...\n}\n}\nWhile the app is loading, the user will see the initial render output. Then, when it‚Äôs loaded and hydrated, your Effect will run and set\ndidMount\nto\ntrue\n, triggering a re-render. This will switch to the client-only render output. Effects don‚Äôt run on the server, so this is why\ndidMount\nwas\nfalse\nduring the initial server render.\nUse this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time‚Äîpotentially, many seconds‚Äîso you don‚Äôt want to make jarring changes to your component‚Äôs appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.\nTroubleshooting\nMy Effect runs twice when the component mounts\nWhen Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.\nThis is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as in development).\nRead more about\nhow this helps find bugs\nand\nhow to fix your logic.\nMy Effect runs after every re-render\nFirst, check that you haven‚Äôt forgotten to specify the dependency array:\nuseEffect\n(\n(\n)\n=>\n{\n// ...\n}\n)\n;\n// üö© No dependency array: re-runs after every render!\nIf you‚Äôve specified the dependency array but your Effect still re-runs in a loop, it‚Äôs because one of your dependencies is different on every re-render.\nYou can debug this problem by manually logging your dependencies to the console:\nuseEffect\n(\n(\n)\n=>\n{\n// ..\n}\n,\n[\nserverUrl\n,\nroomId\n]\n)\n;\nconsole\n.\nlog\n(\n[\nserverUrl\n,\nroomId\n]\n)\n;\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as\ntemp1\nand the second one got saved as\ntemp2\n, you can then use the browser console to check whether each dependency in both arrays is the same:\nObject\n.\nis\n(\ntemp1\n[\n0\n]\n,\ntemp2\n[\n0\n]\n)\n;\n// Is the first dependency the same between the arrays?\nObject\n.\nis\n(\ntemp1\n[\n1\n]\n,\ntemp2\n[\n1\n]\n)\n;\n// Is the second dependency the same between the arrays?\nObject\n.\nis\n(\ntemp1\n[\n2\n]\n,\ntemp2\n[\n2\n]\n)\n;\n// ... and so on for every dependency ...\nWhen you find the dependency that is different on every re-render, you can usually fix it in one of these ways:\nUpdating state based on previous state from an Effect\nRemoving unnecessary object dependencies\nRemoving unnecessary function dependencies\nReading the latest props and state from an Effect\nAs a last resort (if these methods didn‚Äôt help), wrap its creation with\nuseMemo\nor\nuseCallback\n(for functions).\nMy Effect keeps re-running in an infinite cycle\nIf your Effect runs in an infinite cycle, these two things must be true:\nYour Effect is updating some state.\nThat state leads to a re-render, which causes the Effect‚Äôs dependencies to change.\nBefore you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application‚Äôs data flow with it?\nIf there is no external system, consider whether\nremoving the Effect altogether\nwould simplify your logic.\nIf you‚Äôre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component‚Äôs visual output? If you need to keep track of some data that isn‚Äôt used by rendering, a\nref\n(which doesn‚Äôt trigger re-renders) might be more appropriate. Verify your Effect doesn‚Äôt update the state (and trigger re-renders) more than needed.\nFinally, if your Effect is updating the state at the right time, but there is still a loop, it‚Äôs because that state update leads to one of the Effect‚Äôs dependencies changing.\nRead how to debug dependency changes.\nMy cleanup logic runs even though my component didn‚Äôt unmount\nThe cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React\nruns setup+cleanup one extra time immediately after component mounts.\nIf you have cleanup code without corresponding setup code, it‚Äôs usually a code smell:\nuseEffect\n(\n(\n)\n=>\n{\n// üî¥ Avoid: Cleanup logic without corresponding setup logic\nreturn\n(\n)\n=>\n{\ndoSomething\n(\n)\n;\n}\n;\n}\n,\n[\n]\n)\n;\nYour cleanup logic should be ‚Äúsymmetrical‚Äù to the setup logic, and should stop or undo whatever setup did:\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nserverUrl\n,\nroomId\n]\n)\n;\nLearn how the Effect lifecycle is different from the component‚Äôs lifecycle.\nMy Effect does something visual, and I see a flicker before it runs\nIf your Effect must block the browser from\npainting the screen,\nreplace\nuseEffect\nwith\nuseLayoutEffect\n. Note that\nthis shouldn‚Äôt be needed for the vast majority of Effects.\nYou‚Äôll only need this if it‚Äôs crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.\nPrevious\nuseDeferredValue\nNext\nuseId",
    "url": "https://react.dev/reference/react/useEffect",
    "source": "react",
    "doc_type": "api_reference",
    "scraped_at": 12304.9398524
  },
  {
    "title": "React Labs: What We've Been Working On ‚Äì February 2024",
    "content": "Blog\nReact Labs: What We've Been Working On ‚Äì February 2024\nFebruary 15, 2024 by\nJoseph Savona\n,\nRicky Hanlon\n,\nAndrew Clark\n,\nMatt Carroll\n, and\nDan Abramov\n.\nIn React Labs posts, we write about projects in active research and development. We‚Äôve made significant progress since our\nlast update\n, and we‚Äôd like to share our progress.\nNote\nReact Conf 2024 is scheduled for May 15‚Äì16 in Henderson, Nevada! If you‚Äôre interested in attending React Conf in person, you can\nsign up for the ticket lottery\nuntil February 28th.\nFor more info on tickets, free streaming, sponsoring, and more, see\nthe React Conf website\n.\nReact Compiler\nReact Compiler is no longer a research project: the compiler now powers instagram.com in production, and we are working to ship the compiler across additional surfaces at Meta and to prepare the first open source release.\nAs discussed in our\nprevious post\n, React can\nsometimes\nre-render too much when state changes. Since the early days of React our solution for such cases has been manual memoization. In our current APIs, this means applying the\nuseMemo\n,\nuseCallback\n, and\nmemo\nAPIs to manually tune how much React re-renders on state changes. But manual memoization is a compromise. It clutters up our code, is easy to get wrong, and requires extra work to keep up to date.\nManual memoization is a reasonable compromise, but we weren‚Äôt satisfied. Our vision is for React to\nautomatically\nre-render just the right parts of the UI when state changes,\nwithout compromising on React‚Äôs core mental model\n. We believe that React‚Äôs approach ‚Äî UI as a simple function of state, with standard JavaScript values and idioms ‚Äî is a key part of why React has been approachable for so many developers. That‚Äôs why we‚Äôve invested in building an optimizing compiler for React.\nJavaScript is a notoriously challenging language to optimize, thanks to its loose rules and dynamic nature. React Compiler is able to compile code safely by modeling both the rules of JavaScript\nand\nthe ‚Äúrules of React‚Äù. For example, React components must be idempotent ‚Äî returning the same value given the same inputs ‚Äî and can‚Äôt mutate props or state values. These rules limit what developers can do and help to carve out a safe space for the compiler to optimize.\nOf course, we understand that developers sometimes bend the rules a bit, and our goal is to make React Compiler work out of the box on as much code as possible. The compiler attempts to detect when code doesn‚Äôt strictly follow React‚Äôs rules and will either compile the code where safe or skip compilation if it isn‚Äôt safe. We‚Äôre testing against Meta‚Äôs large and varied codebase in order to help validate this approach.\nFor developers who are curious about making sure their code follows React‚Äôs rules, we recommend\nenabling Strict Mode\nand\nconfiguring React‚Äôs ESLint plugin\n. These tools can help to catch subtle bugs in your React code, improving the quality of your applications today, and future-proofs your applications for upcoming features such as React Compiler. We are also working on consolidated documentation of the rules of React and updates to our ESLint plugin to help teams understand and apply these rules to create more robust apps.\nTo see the compiler in action, you can check out our\ntalk from last fall\n. At the time of the talk, we had early experimental data from trying React Compiler on one page of instagram.com. Since then, we shipped the compiler to production across instagram.com. We‚Äôve also expanded our team to accelerate the rollout to additional surfaces at Meta and to open source. We‚Äôre excited about the path ahead and will have more to share in the coming months.\nActions\nWe\npreviously shared\nthat we were exploring solutions for sending data from the client to the server with Server Actions, so that you can execute database mutations and implement forms. During development of Server Actions, we extended these APIs to support data handling in client-only applications as well.\nWe refer to this broader collection of features as simply ‚ÄúActions‚Äù. Actions allow you to pass a function to DOM elements such as\n<form/>\n:\n<\nform\naction\n=\n{\nsearch\n}\n>\n<\ninput\nname\n=\n\"query\"\n/>\n<\nbutton\ntype\n=\n\"submit\"\n>\nSearch\n</\nbutton\n>\n</\nform\n>\nThe\naction\nfunction can operate synchronously or asynchronously. You can define them on the client side using standard JavaScript or on the server with the\n'use server'\ndirective. When using an action, React will manage the life cycle of the data submission for you, providing hooks like\nuseFormStatus\n, and\nuseActionState\nto access the current state and response of the form action.\nBy default, Actions are submitted within a\ntransition\n, keeping the current page interactive while the action is processing. Since Actions support async functions, we‚Äôve also added the ability to use\nasync/await\nin transitions. This allows you to show pending UI with the\nisPending\nstate of a transition when an async request like\nfetch\nstarts, and show the pending UI all the way through the update being applied.\nAlongside Actions, we‚Äôre introducing a feature named\nuseOptimistic\nfor managing optimistic state updates. With this hook, you can apply temporary updates that are automatically reverted once the final state commits. For Actions, this allows you to optimistically set the final state of the data on the client, assuming the submission is successful, and revert to the value for data received from the server. It works using regular\nasync\n/\nawait\n, so it works the same whether you‚Äôre using\nfetch\non the client, or a Server Action from the server.\nLibrary authors can implement custom\naction={fn}\nprops in their own components with\nuseTransition\n. Our intent is for libraries to adopt the Actions pattern when designing their component APIs, to provide a consistent experience for React developers. For example, if your library provides a\n<Calendar onSelect={eventHandler}>\ncomponent, consider also exposing a\n<Calendar selectAction={action}>\nAPI, too.\nWhile we initially focused on Server Actions for client-server data transfer, our philosophy for React is to provide the same programming model across all platforms and environments. When possible, if we introduce a feature on the client, we aim to make it also work on the server, and vice versa. This philosophy allows us to create a single set of APIs that work no matter where your app runs, making it easier to upgrade to different environments later.\nActions are now available in the Canary channel and will ship in the next release of React.\nNew Features in React Canary\nWe introduced\nReact Canaries\nas an option to adopt individual new stable features as soon as their design is close to final, before they‚Äôre released in a stable semver version.\nCanaries are a change to the way we develop React. Previously, features would be researched and built privately inside of Meta, so users would only see the final polished product when released to Stable. With Canaries, we‚Äôre building in public with the help of the community to finalize features we share in the React Labs blog series. This means you hear about new features sooner, as they‚Äôre being finalized instead of after they‚Äôre complete.\nReact Server Components, Asset Loading, Document Metadata, and Actions have all landed in the React Canary, and we‚Äôve added docs for these features on react.dev:\nDirectives\n:\n\"use client\"\nand\n\"use server\"\nare bundler features designed for full-stack React frameworks. They mark the ‚Äúsplit points‚Äù between the two environments:\n\"use client\"\ninstructs the bundler to generate a\n<script>\ntag (like\nAstro Islands\n), while\n\"use server\"\ntells the bundler to generate a POST endpoint (like\ntRPC Mutations\n). Together, they let you write reusable components that compose client-side interactivity with the related server-side logic.\nDocument Metadata\n: we added built-in support for rendering\n<title>\n,\n<meta>\n, and metadata\n<link>\ntags anywhere in your component tree. These work the same way in all environments, including fully client-side code, SSR, and RSC. This provides built-in support for features pioneered by libraries like\nReact Helmet\n.\nAsset Loading\n: we integrated Suspense with the loading lifecycle of resources such as stylesheets, fonts, and scripts so that React takes them into account to determine whether the content in elements like\n<style>\n,\n<link>\n, and\n<script>\nare ready to be displayed. We‚Äôve also added new\nResource Loading APIs\nlike\npreload\nand\npreinit\nto provide greater control for when a resource should load and initialize.\nActions\n: As shared above, we‚Äôve added Actions to manage sending data from the client to the server. You can add\naction\nto elements like\n<form/>\n, access the status with\nuseFormStatus\n, handle the result with\nuseActionState\n, and optimistically update the UI with\nuseOptimistic\n.\nSince all of these features work together, it‚Äôs difficult to release them in the Stable channel individually. Releasing Actions without the complementary hooks for accessing form states would limit the practical usability of Actions. Introducing React Server Components without integrating Server Actions would complicate modifying data on the server.\nBefore we can release a set of features to the Stable channel, we need to ensure they work cohesively and developers have everything they need to use them in production. React Canaries allow us to develop these features individually, and release the stable APIs incrementally until the entire feature set is complete.\nThe current set of features in React Canary are complete and ready to release.\nThe Next Major Version of React\nAfter a couple of years of iteration,\nreact@canary\nis now ready to ship to\nreact@latest\n. The new features mentioned above are compatible with any environment your app runs in, providing everything needed for production use. Since Asset Loading and Document Metadata may be a breaking change for some apps, the next version of React will be a major version:\nReact 19\n.\nThere‚Äôs still more to be done to prepare for release. In React 19, we‚Äôre also adding long-requested improvements which require breaking changes like support for Web Components. Our focus now is to land these changes, prepare for release, finalize docs for new features, and publish announcements for what‚Äôs included.\nWe‚Äôll share more information about everything React 19 includes, how to adopt the new client features, and how to build support for React Server Components in the coming months.\nOffscreen (renamed to Activity).\nSince our last update, we‚Äôve renamed a capability we‚Äôre researching from ‚ÄúOffscreen‚Äù to ‚ÄúActivity‚Äù. The name ‚ÄúOffscreen‚Äù implied that it only applied to parts of the app that were not visible, but while researching the feature we realized that it‚Äôs possible for parts of the app to be visible and inactive, such as content behind a modal. The new name more closely reflects the behavior of marking certain parts of the app ‚Äúactive‚Äù or ‚Äúinactive‚Äù.\nActivity is still under research and our remaining work is to finalize the primitives that are exposed to library developers. We‚Äôve deprioritized this area while we focus on shipping features that are more complete.\nIn addition to this update, our team has presented at conferences and made appearances on podcasts to speak more on our work and answer questions.\nSathya Gunasekaran\nspoke about the React Compiler at the\nReact India\nconference\nDan Abramov\ngave a talk at\nRemixConf\ntitled ‚ÄúReact from Another Dimension‚Äù which explores an alternative history of how React Server Components and Actions could have been created\nDan Abramov\nwas interviewed on\nthe Changelog‚Äôs JS Party podcast\nabout React Server Components\nMatt Carroll\nwas interviewed on the\nFront-End Fire podcast\nwhere he discussed\nThe Two Reacts\nThanks\nLauren Tan\n,\nSophie Alpert\n,\nJason Bonta\n,\nEli White\n, and\nSathya Gunasekaran\nfor reviewing this post.\nThanks for reading, and\nsee you at React Conf\n!\nPrevious\nReact 19 RC Upgrade Guide\nNext\nReact Canaries: Enabling Incremental Feature Rollout Outside Meta",
    "url": "https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024",
    "source": "react",
    "doc_type": "example",
    "scraped_at": 12305.3335393
  },
  {
    "title": "Reacting to Input with State",
    "content": "Learn React\nManaging State\nReacting to Input with State\nReact provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.\nYou will learn\nHow declarative UI programming differs from imperative UI programming\nHow to enumerate the different visual states your component can be in\nHow to trigger the changes between the different visual states from code\nHow declarative UI compares to imperative\nWhen you design UI interactions, you probably think about how the UI\nchanges\nin response to user actions. Consider a form that lets the user submit an answer:\nWhen you type something into the form, the ‚ÄúSubmit‚Äù button\nbecomes enabled.\nWhen you press ‚ÄúSubmit‚Äù, both the form and the button\nbecome disabled,\nand a spinner\nappears.\nIf the network request succeeds, the form\ngets hidden,\nand the ‚ÄúThank you‚Äù message\nappears.\nIf the network request fails, an error message\nappears,\nand the form\nbecomes enabled\nagain.\nIn\nimperative programming,\nthe above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here‚Äôs another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go.\nIllustrated by\nRachel Lee Nabors\nThey don‚Äôt know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It‚Äôs called\nimperative\nbecause you have to ‚Äúcommand‚Äù each element, from the spinner to the button, telling the computer\nhow\nto update the UI.\nIn this example of imperative UI programming, the form is built\nwithout\nReact. It only uses the browser\nDOM\n:\nindex.js\nindex.html\nindex.js\nReset\nFork\nasync\nfunction\nhandleFormSubmit\n(\ne\n)\n{\ne\n.\npreventDefault\n(\n)\n;\ndisable\n(\ntextarea\n)\n;\ndisable\n(\nbutton\n)\n;\nshow\n(\nloadingMessage\n)\n;\nhide\n(\nerrorMessage\n)\n;\ntry\n{\nawait\nsubmitForm\n(\ntextarea\n.\nvalue\n)\n;\nshow\n(\nsuccessMessage\n)\n;\nhide\n(\nform\n)\n;\n}\ncatch\n(\nerr\n)\n{\nshow\n(\nerrorMessage\n)\n;\nerrorMessage\n.\ntextContent\n=\nerr\n.\nmessage\n;\n}\nfinally\n{\nhide\n(\nloadingMessage\n)\n;\nenable\n(\ntextarea\n)\n;\nenable\n(\nbutton\n)\n;\n}\n}\nfunction\nhandleTextareaChange\n(\n)\n{\nif\n(\ntextarea\n.\nvalue\n.\nlength\n===\n0\n)\n{\ndisable\n(\nbutton\n)\n;\n}\nelse\n{\nenable\n(\nbutton\n)\n;\n}\n}\nfunction\nhide\n(\nel\n)\n{\nel\n.\nstyle\n.\ndisplay\n=\n'none'\n;\n}\nfunction\nshow\n(\nel\n)\n{\nel\n.\nstyle\n.\ndisplay\n=\n''\n;\n}\nfunction\nenable\n(\nel\n)\n{\nel\n.\ndisabled\n=\nfalse\n;\n}\nfunction\ndisable\n(\nel\n)\n{\nel\n.\ndisabled\n=\ntrue\n;\n}\nfunction\nsubmitForm\n(\nanswer\n)\n{\n// Pretend it's hitting the network.\nreturn\nnew\nPromise\n(\n(\nresolve\n,\nreject\n)\n=>\n{\nsetTimeout\n(\n(\n)\n=>\n{\nif\n(\nanswer\n.\ntoLowerCase\n(\n)\n===\n'istanbul'\n)\n{\nresolve\n(\n)\n;\n}\nelse\n{\nreject\n(\nnew\nError\n(\n'Good guess but a wrong answer. Try again!'\n)\n)\n;\n}\n}\n,\n1500\n)\n;\n}\n)\n;\n}\nlet\nform\n=\ndocument\n.\ngetElementById\n(\n'form'\n)\n;\nlet\ntextarea\n=\ndocument\n.\ngetElementById\n(\n'textarea'\n)\n;\nlet\nbutton\n=\ndocument\n.\ngetElementById\n(\n'button'\n)\n;\nlet\nloadingMessage\n=\ndocument\n.\ngetElementById\n(\n'loading'\n)\n;\nlet\nerrorMessage\n=\ndocument\n.\ngetElementById\n(\n'error'\n)\n;\nlet\nsuccessMessage\n=\ndocument\n.\ngetElementById\n(\n'success'\n)\n;\nform\n.\nonsubmit\n=\nhandleFormSubmit\n;\ntextarea\n.\noninput\n=\nhandleTextareaChange\n;\nShow more\nManipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven‚Äôt introduced a bug (for example, forgetting to show or hide something).\nReact was built to solve this problem.\nIn React, you don‚Äôt directly manipulate the UI‚Äîmeaning you don‚Äôt enable, disable, show, or hide components directly. Instead, you\ndeclare what you want to show,\nand React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It‚Äôs the driver‚Äôs job to get you there, and they might even know some shortcuts you haven‚Äôt considered!\nIllustrated by\nRachel Lee Nabors\nThinking about UI declaratively\nYou‚Äôve seen how to implement a form imperatively above. To better understand how to think in React, you‚Äôll walk through reimplementing this UI in React below:\nIdentify\nyour component‚Äôs different visual states\nDetermine\nwhat triggers those state changes\nRepresent\nthe state in memory using\nuseState\nRemove\nany non-essential state variables\nConnect\nthe event handlers to set the state\nStep 1: Identify your component‚Äôs different visual states\nIn computer science, you may hear about a\n‚Äústate machine‚Äù\nbeing in one of several ‚Äústates‚Äù. If you work with a designer, you may have seen mockups for different ‚Äúvisual states‚Äù. React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration.\nFirst, you need to visualize all the different ‚Äústates‚Äù of the UI the user might see:\nEmpty\n: Form has a disabled ‚ÄúSubmit‚Äù button.\nTyping\n: Form has an enabled ‚ÄúSubmit‚Äù button.\nSubmitting\n: Form is completely disabled. Spinner is shown.\nSuccess\n: ‚ÄúThank you‚Äù message is shown instead of a form.\nError\n: Same as Typing state, but with an extra error message.\nJust like a designer, you‚Äôll want to ‚Äúmock up‚Äù or create ‚Äúmocks‚Äù for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop called\nstatus\nwith a default value of\n'empty'\n:\nApp.js\nApp.js\nReset\nFork\nexport\ndefault\nfunction\nForm\n(\n{\nstatus\n=\n'empty'\n}\n)\n{\nif\n(\nstatus\n===\n'success'\n)\n{\nreturn\n<\nh1\n>\nThat's right!\n</\nh1\n>\n}\nreturn\n(\n<\n>\n<\nh2\n>\nCity quiz\n</\nh2\n>\n<\np\n>\nIn which city is there a billboard that turns air into drinkable water?\n</\np\n>\n<\nform\n>\n<\ntextarea\n/>\n<\nbr\n/>\n<\nbutton\n>\nSubmit\n</\nbutton\n>\n</\nform\n>\n</\n>\n)\n}\nShow more\nYou could call that prop anything you like, the naming is not important. Try editing\nstatus = 'empty'\nto\nstatus = 'success'\nto see the success message appear. Mocking lets you quickly iterate on the UI before you wire up any logic. Here is a more fleshed out prototype of the same component, still ‚Äúcontrolled‚Äù by the\nstatus\nprop:\nApp.js\nApp.js\nReset\nFork\nexport\ndefault\nfunction\nForm\n(\n{\n// Try 'submitting', 'error', 'success':\nstatus\n=\n'empty'\n}\n)\n{\nif\n(\nstatus\n===\n'success'\n)\n{\nreturn\n<\nh1\n>\nThat's right!\n</\nh1\n>\n}\nreturn\n(\n<\n>\n<\nh2\n>\nCity quiz\n</\nh2\n>\n<\np\n>\nIn which city is there a billboard that turns air into drinkable water?\n</\np\n>\n<\nform\n>\n<\ntextarea\ndisabled\n=\n{\nstatus\n===\n'submitting'\n}\n/>\n<\nbr\n/>\n<\nbutton\ndisabled\n=\n{\nstatus\n===\n'empty'\n||\nstatus\n===\n'submitting'\n}\n>\nSubmit\n</\nbutton\n>\n{\nstatus\n===\n'error'\n&&\n<\np\nclassName\n=\n\"Error\"\n>\nGood guess but a wrong answer. Try again!\n</\np\n>\n}\n</\nform\n>\n</\n>\n)\n;\n}\nShow more\nDeep Dive\nDisplaying many visual states at once\nShow Details\nIf a component has a lot of visual states, it can be convenient to show them all on one page:\nApp.js\nForm.js\nApp.js\nReset\nFork\nimport\nForm\nfrom\n'./Form.js'\n;\nlet\nstatuses\n=\n[\n'empty'\n,\n'typing'\n,\n'submitting'\n,\n'success'\n,\n'error'\n,\n]\n;\nexport\ndefault\nfunction\nApp\n(\n)\n{\nreturn\n(\n<\n>\n{\nstatuses\n.\nmap\n(\nstatus\n=>\n(\n<\nsection\nkey\n=\n{\nstatus\n}\n>\n<\nh4\n>\nForm (\n{\nstatus\n}\n):\n</\nh4\n>\n<\nForm\nstatus\n=\n{\nstatus\n}\n/>\n</\nsection\n>\n)\n)\n}\n</\n>\n)\n;\n}\nShow more\nPages like this are often called ‚Äúliving styleguides‚Äù or ‚Äústorybooks‚Äù.\nStep 2: Determine what triggers those state changes\nYou can trigger state updates in response to two kinds of inputs:\nHuman inputs,\nlike clicking a button, typing in a field, navigating a link.\nComputer inputs,\nlike a network response arriving, a timeout completing, an image loading.\nHuman inputs\nComputer inputs\nIllustrated by\nRachel Lee Nabors\nIn both cases,\nyou must set\nstate variables\nto update the UI.\nFor the form you‚Äôre developing, you will need to change state in response to a few different inputs:\nChanging the text input\n(human) should switch it from the\nEmpty\nstate to the\nTyping\nstate or back, depending on whether the text box is empty or not.\nClicking the Submit button\n(human) should switch it to the\nSubmitting\nstate.\nSuccessful network response\n(computer) should switch it to the\nSuccess\nstate.\nFailed network response\n(computer) should switch it to the\nError\nstate with the matching error message.\nNote\nNotice that human inputs often require\nevent handlers\n!\nTo help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation.\nForm states\nStep 3: Represent the state in memory with\nuseState\nNext you‚Äôll need to represent the visual states of your component in memory with\nuseState\n.\nSimplicity is key: each piece of state is a ‚Äúmoving piece‚Äù, and\nyou want as few ‚Äúmoving pieces‚Äù as possible.\nMore complexity leads to more bugs!\nStart with the state that\nabsolutely must\nbe there. For example, you‚Äôll need to store the\nanswer\nfor the input, and the\nerror\n(if it exists) to store the last error:\nconst\n[\nanswer\n,\nsetAnswer\n]\n=\nuseState\n(\n''\n)\n;\nconst\n[\nerror\n,\nsetError\n]\n=\nuseState\n(\nnull\n)\n;\nThen, you‚Äôll need a state variable representing which one of the visual states that you want to display. There‚Äôs usually more than a single way to represent that in memory, so you‚Äôll need to experiment with it.\nIf you struggle to think of the best way immediately, start by adding enough state that you‚Äôre\ndefinitely\nsure that all the possible visual states are covered:\nconst\n[\nisEmpty\n,\nsetIsEmpty\n]\n=\nuseState\n(\ntrue\n)\n;\nconst\n[\nisTyping\n,\nsetIsTyping\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n[\nisSubmitting\n,\nsetIsSubmitting\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n[\nisSuccess\n,\nsetIsSuccess\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n[\nisError\n,\nsetIsError\n]\n=\nuseState\n(\nfalse\n)\n;\nYour first idea likely won‚Äôt be the best, but that‚Äôs ok‚Äîrefactoring state is a part of the process!\nStep 4: Remove any non-essential state variables\nYou want to avoid duplication in the state content so you‚Äôre only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is to\nprevent the cases where the state in memory doesn‚Äôt represent any valid UI that you‚Äôd want a user to see.\n(For example, you never want to show an error message and disable the input at the same time, or the user won‚Äôt be able to correct the error!)\nHere are some questions you can ask about your state variables:\nDoes this state cause a paradox?\nFor example,\nisTyping\nand\nisSubmitting\ncan‚Äôt both be\ntrue\n. A paradox usually means that the state is not constrained enough. There are four possible combinations of two booleans, but only three correspond to valid states. To remove the ‚Äúimpossible‚Äù state, you can combine these into a\nstatus\nthat must be one of three values:\n'typing'\n,\n'submitting'\n, or\n'success'\n.\nIs the same information available in another state variable already?\nAnother paradox:\nisEmpty\nand\nisTyping\ncan‚Äôt be\ntrue\nat the same time. By making them separate state variables, you risk them going out of sync and causing bugs. Fortunately, you can remove\nisEmpty\nand instead check\nanswer.length === 0\n.\nCan you get the same information from the inverse of another state variable?\nisError\nis not needed because you can check\nerror !== null\ninstead.\nAfter this clean-up, you‚Äôre left with 3 (down from 7!)\nessential\nstate variables:\nconst\n[\nanswer\n,\nsetAnswer\n]\n=\nuseState\n(\n''\n)\n;\nconst\n[\nerror\n,\nsetError\n]\n=\nuseState\n(\nnull\n)\n;\nconst\n[\nstatus\n,\nsetStatus\n]\n=\nuseState\n(\n'typing'\n)\n;\n// 'typing', 'submitting', or 'success'\nYou know they are essential, because you can‚Äôt remove any of them without breaking the functionality.\nDeep Dive\nEliminating ‚Äúimpossible‚Äù states with a reducer\nShow Details\nThese three variables are a good enough representation of this form‚Äôs state. However, there are still some intermediate states that don‚Äôt fully make sense. For example, a non-null\nerror\ndoesn‚Äôt make sense when\nstatus\nis\n'success'\n. To model the state more precisely, you can\nextract it into a reducer.\nReducers let you unify multiple state variables into a single object and consolidate all the related logic!\nStep 5: Connect the event handlers to set state\nLastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:\nApp.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n}\nfrom\n'react'\n;\nexport\ndefault\nfunction\nForm\n(\n)\n{\nconst\n[\nanswer\n,\nsetAnswer\n]\n=\nuseState\n(\n''\n)\n;\nconst\n[\nerror\n,\nsetError\n]\n=\nuseState\n(\nnull\n)\n;\nconst\n[\nstatus\n,\nsetStatus\n]\n=\nuseState\n(\n'typing'\n)\n;\nif\n(\nstatus\n===\n'success'\n)\n{\nreturn\n<\nh1\n>\nThat's right!\n</\nh1\n>\n}\nasync\nfunction\nhandleSubmit\n(\ne\n)\n{\ne\n.\npreventDefault\n(\n)\n;\nsetStatus\n(\n'submitting'\n)\n;\ntry\n{\nawait\nsubmitForm\n(\nanswer\n)\n;\nsetStatus\n(\n'success'\n)\n;\n}\ncatch\n(\nerr\n)\n{\nsetStatus\n(\n'typing'\n)\n;\nsetError\n(\nerr\n)\n;\n}\n}\nfunction\nhandleTextareaChange\n(\ne\n)\n{\nsetAnswer\n(\ne\n.\ntarget\n.\nvalue\n)\n;\n}\nreturn\n(\n<\n>\n<\nh2\n>\nCity quiz\n</\nh2\n>\n<\np\n>\nIn which city is there a billboard that turns air into drinkable water?\n</\np\n>\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n}\n>\n<\ntextarea\nvalue\n=\n{\nanswer\n}\nonChange\n=\n{\nhandleTextareaChange\n}\ndisabled\n=\n{\nstatus\n===\n'submitting'\n}\n/>\n<\nbr\n/>\n<\nbutton\ndisabled\n=\n{\nanswer\n.\nlength\n===\n0\n||\nstatus\n===\n'submitting'\n}\n>\nSubmit\n</\nbutton\n>\n{\nerror\n!==\nnull\n&&\n<\np\nclassName\n=\n\"Error\"\n>\n{\nerror\n.\nmessage\n}\n</\np\n>\n}\n</\nform\n>\n</\n>\n)\n;\n}\nfunction\nsubmitForm\n(\nanswer\n)\n{\n// Pretend it's hitting the network.\nreturn\nnew\nPromise\n(\n(\nresolve\n,\nreject\n)\n=>\n{\nsetTimeout\n(\n(\n)\n=>\n{\nlet\nshouldError\n=\nanswer\n.\ntoLowerCase\n(\n)\n!==\n'lima'\nif\n(\nshouldError\n)\n{\nreject\n(\nnew\nError\n(\n'Good guess but a wrong answer. Try again!'\n)\n)\n;\n}\nelse\n{\nresolve\n(\n)\n;\n}\n}\n,\n1500\n)\n;\n}\n)\n;\n}\nShow more\nAlthough this code is longer than the original imperative example, it is much less fragile. Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself.\nRecap\nDeclarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).\nWhen developing a component:\nIdentify all its visual states.\nDetermine the human and computer triggers for state changes.\nModel the state with\nuseState\n.\nRemove non-essential state to avoid bugs and paradoxes.\nConnect the event handlers to set state.\nTry out some challenges\n1\n.\nAdd and remove a CSS class\n2\n.\nProfile editor\n3\n.\nRefactor the imperative solution without React\nChallenge\n1\nof\n3\n:\nAdd and remove a CSS class\nMake it so that clicking on the picture\nremoves\nthe\nbackground--active\nCSS class from the outer\n<div>\n, but\nadds\nthe\npicture--active\nclass to the\n<img>\n. Clicking the background again should restore the original CSS classes.\nVisually, you should expect that clicking on the picture removes the purple background and highlights the picture border. Clicking outside the picture highlights the background, but removes the picture border highlight.\nApp.js\nApp.js\nReset\nFork\nexport\ndefault\nfunction\nPicture\n(\n)\n{\nreturn\n(\n<\ndiv\nclassName\n=\n\"background background--active\"\n>\n<\nimg\nclassName\n=\n\"picture\"\nalt\n=\n\"Rainbow houses in Kampung Pelangi, Indonesia\"\nsrc\n=\n\"https://i.imgur.com/5qwVYb1.jpeg\"\n/>\n</\ndiv\n>\n)\n;\n}\nShow solution\nNext\nChallenge\nPrevious\nManaging State\nNext\nChoosing the State Structure",
    "url": "https://react.dev/learn/reacting-to-input-with-state",
    "source": "react",
    "doc_type": "tutorial",
    "scraped_at": 12305.603375
  },
  {
    "title": "renderToReadableStream",
    "content": "API Reference\nServer APIs\nrenderToReadableStream\nrenderToReadableStream\nrenders a React tree to a\nReadable Web Stream.\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\nreactNode\n,\noptions\n?\n)\nReference\nrenderToReadableStream(reactNode, options?)\nUsage\nRendering a React tree as HTML to a Readable Web Stream\nStreaming more content as it loads\nSpecifying what goes into the shell\nLogging crashes on the server\nRecovering from errors inside the shell\nRecovering from errors outside the shell\nSetting the status code\nHandling different errors in different ways\nWaiting for all content to load for crawlers and static generation\nAborting server rendering\nNote\nThis API depends on\nWeb Streams.\nFor Node.js, use\nrenderToPipeableStream\ninstead.\nReference\nrenderToReadableStream(reactNode, options?)\nCall\nrenderToReadableStream\nto render your React tree as HTML into a\nReadable Web Stream.\nimport\n{\nrenderToReadableStream\n}\nfrom\n'react-dom/server'\n;\nasync\nfunction\nhandler\n(\nrequest\n)\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\nOn the client, call\nhydrateRoot\nto make the server-generated HTML interactive.\nSee more examples below.\nParameters\nreactNode\n: A React node you want to render to HTML. For example, a JSX element like\n<App />\n. It is expected to represent the entire document, so the\nApp\ncomponent should render the\n<html>\ntag.\noptional\noptions\n: An object with streaming options.\noptional\nbootstrapScriptContent\n: If specified, this string will be placed in an inline\n<script>\ntag.\noptional\nbootstrapScripts\n: An array of string URLs for the\n<script>\ntags to emit on the page. Use this to include the\n<script>\nthat calls\nhydrateRoot\n.\nOmit it if you don‚Äôt want to run React on the client at all.\noptional\nbootstrapModules\n: Like\nbootstrapScripts\n, but emits\n<script type=\"module\">\ninstead.\noptional\nidentifierPrefix\n: A string prefix React uses for IDs generated by\nuseId\n.\nUseful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to\nhydrateRoot\n.\noptional\nnamespaceURI\n: A string with the root\nnamespace URI\nfor the stream. Defaults to regular HTML. Pass\n'http://www.w3.org/2000/svg'\nfor SVG or\n'http://www.w3.org/1998/Math/MathML'\nfor MathML.\noptional\nnonce\n: A\nnonce\nstring to allow scripts for\nscript-src\nContent-Security-Policy\n.\noptional\nonError\n: A callback that fires whenever there is a server error, whether\nrecoverable\nor\nnot.\nBy default, this only calls\nconsole.error\n. If you override it to\nlog crash reports,\nmake sure that you still call\nconsole.error\n. You can also use it to\nadjust the status code\nbefore the shell is emitted.\noptional\nprogressiveChunkSize\n: The number of bytes in a chunk.\nRead more about the default heuristic.\noptional\nsignal\n: An\nabort signal\nthat lets you\nabort server rendering\nand render the rest on the client.\nReturns\nrenderToReadableStream\nreturns a Promise:\nIf rendering the\nshell\nis successful, that Promise will resolve to a\nReadable Web Stream.\nIf rendering the shell fails, the Promise will be rejected.\nUse this to output a fallback shell.\nThe returned stream has an additional property:\nallReady\n: A Promise that resolves when all rendering is complete, including both the\nshell\nand all additional\ncontent.\nYou can\nawait stream.allReady\nbefore returning a response\nfor crawlers and static generation.\nIf you do that, you won‚Äôt get any progressive loading. The stream will contain the final HTML.\nUsage\nRendering a React tree as HTML to a Readable Web Stream\nCall\nrenderToReadableStream\nto render your React tree as HTML into a\nReadable Web Stream:\nimport\n{\nrenderToReadableStream\n}\nfrom\n'react-dom/server'\n;\nasync\nfunction\nhandler\n(\nrequest\n)\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<App />\n,\n{\nbootstrapScripts\n:\n['/main.js']\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\nAlong with the\nroot component\n, you need to provide a list of\nbootstrap\n<script>\npaths\n. Your root component should return\nthe entire document including the root\n<html>\ntag.\nFor example, it might look like this:\nexport\ndefault\nfunction\nApp\n(\n)\n{\nreturn\n(\n<\nhtml\n>\n<\nhead\n>\n<\nmeta\ncharSet\n=\n\"utf-8\"\n/>\n<\nmeta\nname\n=\n\"viewport\"\ncontent\n=\n\"width=device-width, initial-scale=1\"\n/>\n<\nlink\nrel\n=\n\"stylesheet\"\nhref\n=\n\"/styles.css\"\n>\n</\nlink\n>\n<\ntitle\n>\nMy app\n</\ntitle\n>\n</\nhead\n>\n<\nbody\n>\n<\nRouter\n/>\n</\nbody\n>\n</\nhtml\n>\n)\n;\n}\nReact will inject the\ndoctype\nand your\nbootstrap\n<script>\ntags\ninto the resulting HTML stream:\n<!DOCTYPE html>\n<\nhtml\n>\n<!-- ... HTML from your components ... -->\n</\nhtml\n>\n<\nscript\nsrc\n=\n\"\n/main.js\n\"\nasync\n=\n\"\"\n>\n</\nscript\n>\nOn the client, your bootstrap script should\nhydrate the entire\ndocument\nwith a call to\nhydrateRoot\n:\nimport\n{\nhydrateRoot\n}\nfrom\n'react-dom/client'\n;\nimport\nApp\nfrom\n'./App.js'\n;\nhydrateRoot\n(\ndocument\n,\n<App />\n)\n;\nThis will attach event listeners to the server-generated HTML and make it interactive.\nDeep Dive\nReading CSS and JS asset paths from the build output\nShow Details\nThe final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of\nstyles.css\nyou might end up with\nstyles.123456.css\n. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.\nHowever, if you don‚Äôt know the asset URLs until after the build, there‚Äôs no way for you to put them in the source code. For example, hardcoding\n\"/styles.css\"\ninto JSX like earlier wouldn‚Äôt work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:\nexport\ndefault\nfunction\nApp\n(\n{\nassetMap\n}\n)\n{\nreturn\n(\n<\nhtml\n>\n<\nhead\n>\n<\ntitle\n>\nMy app\n</\ntitle\n>\n<\nlink\nrel\n=\n\"stylesheet\"\nhref\n=\n{\nassetMap\n[\n'styles.css'\n]\n}\n>\n</\nlink\n>\n</\nhead\n>\n...\n</\nhtml\n>\n)\n;\n}\nOn the server, render\n<App assetMap={assetMap} />\nand pass your\nassetMap\nwith the asset URLs:\n// You'd need to get this JSON from your build tooling, e.g. read it from the build output.\nconst\nassetMap\n=\n{\n'styles.css'\n:\n'/styles.123456.css'\n,\n'main.js'\n:\n'/main.123456.js'\n}\n;\nasync\nfunction\nhandler\n(\nrequest\n)\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\nassetMap\n=\n{\nassetMap\n}\n/>\n,\n{\nbootstrapScripts\n:\n[\nassetMap\n[\n'/main.js'\n]\n]\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\nSince your server is now rendering\n<App assetMap={assetMap} />\n, you need to render it with\nassetMap\non the client too to avoid hydration errors. You can serialize and pass\nassetMap\nto the client like this:\n// You'd need to get this JSON from your build tooling.\nconst\nassetMap\n=\n{\n'styles.css'\n:\n'/styles.123456.css'\n,\n'main.js'\n:\n'/main.123456.js'\n}\n;\nasync\nfunction\nhandler\n(\nrequest\n)\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\nassetMap\n=\n{\nassetMap\n}\n/>\n,\n{\n// Careful: It's safe to stringify() this because this data isn't user-generated.\nbootstrapScriptContent\n:\n`window.assetMap =\n${\nJSON\n.\nstringify\n(\nassetMap\n)\n}\n;`\n,\nbootstrapScripts\n:\n[\nassetMap\n[\n'/main.js'\n]\n]\n,\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\nIn the example above, the\nbootstrapScriptContent\noption adds an extra inline\n<script>\ntag that sets the global\nwindow.assetMap\nvariable on the client. This lets the client code read the same\nassetMap\n:\nimport\n{\nhydrateRoot\n}\nfrom\n'react-dom/client'\n;\nimport\nApp\nfrom\n'./App.js'\n;\nhydrateRoot\n(\ndocument\n,\n<\nApp\nassetMap\n=\n{\nwindow\n.\nassetMap\n}\n/>\n)\n;\nBoth client and server render\nApp\nwith the same\nassetMap\nprop, so there are no hydration errors.\nStreaming more content as it loads\nStreaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\nfunction\nProfilePage\n(\n)\n{\nreturn\n(\n<\nProfileLayout\n>\n<\nProfileCover\n/>\n<\nSidebar\n>\n<\nFriends\n/>\n<\nPhotos\n/>\n</\nSidebar\n>\n<\nPosts\n/>\n</\nProfileLayout\n>\n)\n;\n}\nImagine that loading data for\n<Posts />\ntakes some time. Ideally, you‚Äôd want to show the rest of the profile page content to the user without waiting for the posts. To do this,\nwrap\nPosts\nin a\n<Suspense>\nboundary:\nfunction\nProfilePage\n(\n)\n{\nreturn\n(\n<\nProfileLayout\n>\n<\nProfileCover\n/>\n<\nSidebar\n>\n<\nFriends\n/>\n<\nPhotos\n/>\n</\nSidebar\n>\n<\nSuspense\nfallback\n=\n{\n<\nPostsGlimmer\n/>\n}\n>\n<\nPosts\n/>\n</\nSuspense\n>\n</\nProfileLayout\n>\n)\n;\n}\nThis tells React to start streaming the HTML before\nPosts\nloads its data. React will send the HTML for the loading fallback (\nPostsGlimmer\n) first, and then, when\nPosts\nfinishes loading its data, React will send the remaining HTML along with an inline\n<script>\ntag that replaces the loading fallback with that HTML. From the user‚Äôs perspective, the page will first appear with the\nPostsGlimmer\n, later replaced by the\nPosts\n.\nYou can further\nnest\n<Suspense>\nboundaries\nto create a more granular loading sequence:\nfunction\nProfilePage\n(\n)\n{\nreturn\n(\n<\nProfileLayout\n>\n<\nProfileCover\n/>\n<\nSuspense\nfallback\n=\n{\n<\nBigSpinner\n/>\n}\n>\n<\nSidebar\n>\n<\nFriends\n/>\n<\nPhotos\n/>\n</\nSidebar\n>\n<\nSuspense\nfallback\n=\n{\n<\nPostsGlimmer\n/>\n}\n>\n<\nPosts\n/>\n</\nSuspense\n>\n</\nSuspense\n>\n</\nProfileLayout\n>\n)\n;\n}\nIn this example, React can start streaming the page even earlier. Only\nProfileLayout\nand\nProfileCover\nmust finish rendering first because they are not wrapped in any\n<Suspense>\nboundary. However, if\nSidebar\n,\nFriends\n, or\nPhotos\nneed to load some data, React will send the HTML for the\nBigSpinner\nfallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.\nStreaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the\n<script>\ntags load.\nRead more about how streaming HTML works.\nNote\nOnly Suspense-enabled data sources will activate the Suspense component.\nThey include:\nData fetching with Suspense-enabled frameworks like\nRelay\nand\nNext.js\nLazy-loading component code with\nlazy\nReading the value of a Promise with\nuse\nSuspense\ndoes not\ndetect when data is fetched inside an Effect or event handler.\nThe exact way you would load data in the\nPosts\ncomponent above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\nSpecifying what goes into the shell\nThe part of your app outside of any\n<Suspense>\nboundaries is called\nthe shell:\nfunction\nProfilePage\n(\n)\n{\nreturn\n(\n<\nProfileLayout\n>\n<\nProfileCover\n/>\n<\nSuspense\nfallback\n=\n{\n<\nBigSpinner\n/>\n}\n>\n<\nSidebar\n>\n<\nFriends\n/>\n<\nPhotos\n/>\n</\nSidebar\n>\n<\nSuspense\nfallback\n=\n{\n<\nPostsGlimmer\n/>\n}\n>\n<\nPosts\n/>\n</\nSuspense\n>\n</\nSuspense\n>\n</\nProfileLayout\n>\n)\n;\n}\nIt determines the earliest loading state that the user may see:\n<\nProfileLayout\n>\n<\nProfileCover\n/>\n<\nBigSpinner\n/>\n</\nProfileLayout\n>\nIf you wrap the whole app into a\n<Suspense>\nboundary at the root, the shell will only contain that spinner. However, that‚Äôs not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you‚Äôll want to place the\n<Suspense>\nboundaries so that the shell feels\nminimal but complete\n‚Äîlike a skeleton of the entire page layout.\nThe async call to\nrenderToReadableStream\nwill resolve to a\nstream\nas soon as the entire shell has been rendered. Usually, you‚Äôll start streaming then by creating and returning a response with that\nstream\n:\nasync\nfunction\nhandler\n(\nrequest\n)\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\nBy the time the\nstream\nis returned, components in nested\n<Suspense>\nboundaries might still be loading data.\nLogging crashes on the server\nBy default, all errors on the server are logged to console. You can override this behavior to log crash reports:\nasync\nfunction\nhandler\n(\nrequest\n)\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n,\nonError\n(\nerror\n)\n{\nconsole\n.\nerror\n(\nerror\n)\n;\nlogServerCrashReport\n(\nerror\n)\n;\n}\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\nIf you provide a custom\nonError\nimplementation, don‚Äôt forget to also log errors to the console like above.\nRecovering from errors inside the shell\nIn this example, the shell contains\nProfileLayout\n,\nProfileCover\n, and\nPostsGlimmer\n:\nfunction\nProfilePage\n(\n)\n{\nreturn\n(\n<\nProfileLayout\n>\n<\nProfileCover\n/>\n<\nSuspense\nfallback\n=\n{\n<\nPostsGlimmer\n/>\n}\n>\n<\nPosts\n/>\n</\nSuspense\n>\n</\nProfileLayout\n>\n)\n;\n}\nIf an error occurs while rendering those components, React won‚Äôt have any meaningful HTML to send to the client. Wrap your\nrenderToReadableStream\ncall in a\ntry...catch\nto send a fallback HTML that doesn‚Äôt rely on server rendering as the last resort:\nasync\nfunction\nhandler\n(\nrequest\n)\n{\ntry\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n,\nonError\n(\nerror\n)\n{\nconsole\n.\nerror\n(\nerror\n)\n;\nlogServerCrashReport\n(\nerror\n)\n;\n}\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\ncatch\n(\nerror\n)\n{\nreturn\nnew\nResponse\n(\n'<h1>Something went wrong</h1>'\n,\n{\nstatus\n:\n500\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\n}\nIf there is an error while generating the shell, both\nonError\nand your\ncatch\nblock will fire. Use\nonError\nfor error reporting and use the\ncatch\nblock to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.\nRecovering from errors outside the shell\nIn this example, the\n<Posts />\ncomponent is wrapped in\n<Suspense>\nso it is\nnot\na part of the shell:\nfunction\nProfilePage\n(\n)\n{\nreturn\n(\n<\nProfileLayout\n>\n<\nProfileCover\n/>\n<\nSuspense\nfallback\n=\n{\n<\nPostsGlimmer\n/>\n}\n>\n<\nPosts\n/>\n</\nSuspense\n>\n</\nProfileLayout\n>\n)\n;\n}\nIf an error happens in the\nPosts\ncomponent or somewhere inside it, React will\ntry to recover from it:\nIt will emit the loading fallback for the closest\n<Suspense>\nboundary (\nPostsGlimmer\n) into the HTML.\nIt will ‚Äúgive up‚Äù on trying to render the\nPosts\ncontent on the server anymore.\nWhen the JavaScript code loads on the client, React will\nretry\nrendering\nPosts\non the client.\nIf retrying rendering\nPosts\non the client\nalso\nfails, React will throw the error on the client. As with all the errors thrown during rendering, the\nclosest parent error boundary\ndetermines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.\nIf retrying rendering\nPosts\non the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server\nonError\ncallback and the client\nonRecoverableError\ncallbacks will fire so that you can get notified about the error.\nSetting the status code\nStreaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.\nBy\ndividing your app\ninto the shell (above all\n<Suspense>\nboundaries) and the rest of the content, you‚Äôve already solved a part of this problem. If the shell errors, your\ncatch\nblock will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send ‚ÄúOK‚Äù.\nasync\nfunction\nhandler\n(\nrequest\n)\n{\ntry\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n,\nonError\n(\nerror\n)\n{\nconsole\n.\nerror\n(\nerror\n)\n;\nlogServerCrashReport\n(\nerror\n)\n;\n}\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nstatus\n:\n200\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\ncatch\n(\nerror\n)\n{\nreturn\nnew\nResponse\n(\n'<h1>Something went wrong</h1>'\n,\n{\nstatus\n:\n500\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\n}\nIf a component\noutside\nthe shell (i.e. inside a\n<Suspense>\nboundary) throws an error, React will not stop rendering. This means that the\nonError\ncallback will fire, but your code will continue running without getting into the\ncatch\nblock. This is because React will try to recover from that error on the client,\nas described above.\nHowever, if you‚Äôd like, you can use the fact that something has errored to set the status code:\nasync\nfunction\nhandler\n(\nrequest\n)\n{\ntry\n{\nlet\ndidError\n=\nfalse\n;\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n,\nonError\n(\nerror\n)\n{\ndidError\n=\ntrue\n;\nconsole\n.\nerror\n(\nerror\n)\n;\nlogServerCrashReport\n(\nerror\n)\n;\n}\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nstatus\n:\ndidError\n?\n500\n:\n200\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\ncatch\n(\nerror\n)\n{\nreturn\nnew\nResponse\n(\n'<h1>Something went wrong</h1>'\n,\n{\nstatus\n:\n500\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\n}\nThis will only catch errors outside the shell that happened while generating the initial shell content, so it‚Äôs not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.\nHandling different errors in different ways\nYou can\ncreate your own\nError\nsubclasses\nand use the\ninstanceof\noperator to check which error is thrown. For example, you can define a custom\nNotFoundError\nand throw it from your component. Then you can save the error in\nonError\nand do something different before returning the response depending on the error type:\nasync\nfunction\nhandler\n(\nrequest\n)\n{\nlet\ndidError\n=\nfalse\n;\nlet\ncaughtError\n=\nnull\n;\nfunction\ngetStatusCode\n(\n)\n{\nif\n(\ndidError\n)\n{\nif\n(\ncaughtError\ninstanceof\nNotFoundError\n)\n{\nreturn\n404\n;\n}\nelse\n{\nreturn\n500\n;\n}\n}\nelse\n{\nreturn\n200\n;\n}\n}\ntry\n{\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n,\nonError\n(\nerror\n)\n{\ndidError\n=\ntrue\n;\ncaughtError\n=\nerror\n;\nconsole\n.\nerror\n(\nerror\n)\n;\nlogServerCrashReport\n(\nerror\n)\n;\n}\n}\n)\n;\nreturn\nnew\nResponse\n(\nstream\n,\n{\nstatus\n:\ngetStatusCode\n(\n)\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\ncatch\n(\nerror\n)\n{\nreturn\nnew\nResponse\n(\n'<h1>Something went wrong</h1>'\n,\n{\nstatus\n:\ngetStatusCode\n(\n)\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\n}\nKeep in mind that once you emit the shell and start streaming, you can‚Äôt change the status code.\nWaiting for all content to load for crawlers and static generation\nStreaming offers a better user experience because the user can see the content as it becomes available.\nHowever, when a crawler visits your page, or if you‚Äôre generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.\nYou can wait for all the content to load by awaiting the\nstream.allReady\nPromise:\nasync\nfunction\nhandler\n(\nrequest\n)\n{\ntry\n{\nlet\ndidError\n=\nfalse\n;\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nbootstrapScripts\n:\n[\n'/main.js'\n]\n,\nonError\n(\nerror\n)\n{\ndidError\n=\ntrue\n;\nconsole\n.\nerror\n(\nerror\n)\n;\nlogServerCrashReport\n(\nerror\n)\n;\n}\n}\n)\n;\nlet\nisCrawler\n=\n// ... depends on your bot detection strategy ...\nif\n(\nisCrawler\n)\n{\nawait\nstream\n.\nallReady\n;\n}\nreturn\nnew\nResponse\n(\nstream\n,\n{\nstatus\n:\ndidError\n?\n500\n:\n200\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\ncatch\n(\nerror\n)\n{\nreturn\nnew\nResponse\n(\n'<h1>Something went wrong</h1>'\n,\n{\nstatus\n:\n500\n,\nheaders\n:\n{\n'content-type'\n:\n'text/html'\n}\n,\n}\n)\n;\n}\n}\nA regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for\nall\ndata, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.\nAborting server rendering\nYou can force the server rendering to ‚Äúgive up‚Äù after a timeout:\nasync\nfunction\nhandler\n(\nrequest\n)\n{\ntry\n{\nconst\ncontroller\n=\nnew\nAbortController\n(\n)\n;\nsetTimeout\n(\n(\n)\n=>\n{\ncontroller\n.\nabort\n(\n)\n;\n}\n,\n10000\n)\n;\nconst\nstream\n=\nawait\nrenderToReadableStream\n(\n<\nApp\n/>\n,\n{\nsignal\n:\ncontroller\n.\nsignal\n,\nbootstrapScripts\n:\n[\n'/main.js'\n]\n,\nonError\n(\nerror\n)\n{\ndidError\n=\ntrue\n;\nconsole\n.\nerror\n(\nerror\n)\n;\nlogServerCrashReport\n(\nerror\n)\n;\n}\n}\n)\n;\n// ...\nReact will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.\nPrevious\nrenderToPipeableStream\nNext\nrenderToStaticMarkup",
    "url": "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "source": "react",
    "doc_type": "api_reference",
    "scraped_at": 12305.9507011
  },
  {
    "title": "React Labs: What We've Been Working On ‚Äì June 2022",
    "content": "Blog\nReact Labs: What We've Been Working On ‚Äì June 2022\nJune 15, 2022 by\nAndrew Clark\n,\nDan Abramov\n,\nJan Kassens\n,\nJoseph Savona\n,\nJosh Story\n,\nLauren Tan\n,\nLuna Ruan\n,\nMengdi Chen\n,\nRick Hanlon\n,\nRobert Zhang\n,\nSathya Gunasekaran\n,\nSebastian Markb√•ge\n, and\nXuan Huang\nReact 18\nwas years in the making, and with it brought valuable lessons for the React team. Its release was the result of many years of research and exploring many paths. Some of those paths were successful; many more were dead-ends that led to new insights. One lesson we‚Äôve learned is that it‚Äôs frustrating for the community to wait for new features without having insight into these paths that we‚Äôre exploring.\nWe typically have a number of projects being worked on at any time, ranging from the more experimental to the clearly defined. Looking ahead, we‚Äôd like to start regularly sharing more about what we‚Äôve been working on with the community across these projects.\nTo set expectations, this is not a roadmap with clear timelines. Many of these projects are under active research and are difficult to put concrete ship dates on. They may possibly never even ship in their current iteration depending on what we learn. Instead, we want to share with you the problem spaces we‚Äôre actively thinking about, and what we‚Äôve learned so far.\nServer Components\nWe announced an\nexperimental demo of React Server Components\n(RSC) in December 2020. Since then we‚Äôve been finishing up its dependencies in React 18, and working on changes inspired by experimental feedback.\nIn particular, we‚Äôre abandoning the idea of having forked I/O libraries (eg react-fetch), and instead adopting an async/await model for better compatibility. This doesn‚Äôt technically block RSC‚Äôs release because you can also use routers for data fetching. Another change is that we‚Äôre also moving away from the file extension approach in favor of\nannotating boundaries\n.\nWe‚Äôre working together with Vercel and Shopify to unify bundler support for shared semantics in both webpack and Vite. Before launch, we want to make sure that the semantics of RSCs are the same across the whole React ecosystem. This is the major blocker for reaching stable.\nAsset Loading\nCurrently, assets like scripts, external styles, fonts, and images are typically preloaded and loaded using external systems. This can make it tricky to coordinate across new environments like streaming, Server Components, and more.\nWe‚Äôre looking at adding APIs to preload and load deduplicated external assets through React APIs that work in all React environments.\nWe‚Äôre also looking at having these support Suspense so you can have images, CSS, and fonts that block display until they‚Äôre loaded but don‚Äôt block streaming and concurrent rendering. This can help avoid\n‚Äúpopcorning‚Äú\nas the visuals pop and layout shifts.\nStatic Server Rendering Optimizations\nStatic Site Generation (SSG) and Incremental Static Regeneration (ISR) are great ways to get performance for cacheable pages, but we think we can add features to improve performance of dynamic Server Side Rendering (SSR) ‚Äì especially when most but not all of the content is cacheable. We‚Äôre exploring ways to optimize server rendering utilizing compilation and static passes.\nReact Optimizing Compiler\nWe gave an\nearly preview\nof React Forget at React Conf 2021. It‚Äôs a compiler that automatically generates the equivalent of\nuseMemo\nand\nuseCallback\ncalls to minimize the cost of re-rendering, while retaining React‚Äôs programming model.\nRecently, we finished a rewrite of the compiler to make it more reliable and capable. This new architecture allows us to analyze and memoize more complex patterns such as the use of\nlocal mutations\n, and opens up many new compile-time optimization opportunities beyond just being on par with memoization Hooks.\nWe‚Äôre also working on a playground for exploring many aspects of the compiler. While the goal of the playground is to make development of the compiler easier, we think that it will make it easier to try it out and build intuition for what the compiler does. It reveals various insights into how it works under the hood, and live renders the compiler‚Äôs outputs as you type. This will be shipped together with the compiler when it‚Äôs released.\nOffscreen\nToday, if you want to hide and show a component, you have two options. One is to add or remove it from the tree completely. The problem with this approach is that the state of your UI is lost each time you unmount, including state stored in the DOM, like scroll position.\nThe other option is to keep the component mounted and toggle the appearance visually using CSS. This preserves the state of your UI, but it comes at a performance cost, because React must keep rendering the hidden component and all of its children whenever it receives new updates.\nOffscreen introduces a third option: hide the UI visually, but deprioritize its content. The idea is similar in spirit to the\ncontent-visibility\nCSS property: when content is hidden, it doesn‚Äôt need to stay in sync with the rest of the UI. React can defer the rendering work until the rest of the app is idle, or until the content becomes visible again.\nOffscreen is a low level capability that unlocks high level features. Similar to React‚Äôs other concurrent features like\nstartTransition\n, in most cases you won‚Äôt interact with the Offscreen API directly, but instead via an opinionated framework to implement patterns like:\nInstant transitions.\nSome routing frameworks already prefetch data to speed up subsequent navigations, like when hovering over a link. With Offscreen, they‚Äôll also be able to prerender the next screen in the background.\nReusable state.\nSimilarly, when navigating between routes or tabs, you can use Offscreen to preserve the state of the previous screen so you can switch back and pick up where you left off.\nVirtualized list rendering.\nWhen displaying large lists of items, virtualized list frameworks will prerender more rows than are currently visible. You can use Offscreen to prerender the hidden rows at a lower priority than the visible items in the list.\nBackgrounded content.\nWe‚Äôre also exploring a related feature for deprioritizing content in the background without hiding it, like when displaying a modal overlay.\nTransition Tracing\nCurrently, React has two profiling tools. The\noriginal Profiler\nshows an overview of all the commits in a profiling session. For each commit, it also shows all components that rendered and the amount of time it took for them to render. We also have a beta version of a\nTimeline Profiler\nintroduced in React 18 that shows when components schedule updates and when React works on these updates. Both of these profilers help developers identify performance problems in their code.\nWe‚Äôve realized that developers don‚Äôt find knowing about individual slow commits or components out of context that useful. It‚Äôs more useful to know about what actually causes the slow commits. And that developers want to be able to track specific interactions (eg a button click, an initial load, or a page navigation) to watch for performance regressions and to understand why an interaction was slow and how to fix it.\nWe previously tried to solve this issue by creating an\nInteraction Tracing API\n, but it had some fundamental design flaws that reduced the accuracy of tracking why an interaction was slow and sometimes resulted in interactions never ending. We ended up\nremoving this API\nbecause of these issues.\nWe are working on a new version for the Interaction Tracing API (tentatively called Transition Tracing because it is initiated via\nstartTransition\n) that solves these problems.\nNew React Docs\nLast year, we announced the beta version of the new React documentation website (\nlater shipped as react.dev\n) of the new React documentation website. The new learning materials teach Hooks first and has new diagrams, illustrations, as well as many interactive examples and challenges. We took a break from that work to focus on the React 18 release, but now that React 18 is out, we‚Äôre actively working to finish and ship the new documentation.\nWe are currently writing a detailed section about effects, as we‚Äôve heard that is one of the more challenging topics for both new and experienced React users.\nSynchronizing with Effects\nis the first published page in the series, and there are more to come in the following weeks. When we first started writing a detailed section about effects, we‚Äôve realized that many common effect patterns can be simplified by adding a new primitive to React. We‚Äôve shared some initial thoughts on that in the\nuseEvent RFC\n. It is currently in early research, and we are still iterating on the idea. We appreciate the community‚Äôs comments on the RFC so far, as well as the\nfeedback\nand contributions to the ongoing documentation rewrite. We‚Äôd specifically like to thank\nHarish Kumar\nfor submitting and reviewing many improvements to the new website implementation.\nThanks to\nSophie Alpert\nfor reviewing this blog post!\nPrevious\nIntroducing react.dev\nNext\nReact v18.0",
    "url": "https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022",
    "source": "react",
    "doc_type": "example",
    "scraped_at": 12306.2410597
  },
  {
    "title": "<style>",
    "content": "API Reference\nComponents\n<style>\nThe\nbuilt-in browser\n<style>\ncomponent\nlets you add inline CSS stylesheets to your document.\n<\nstyle\n>\n{\n` p { color: red; } `\n}\n</\nstyle\n>\nReference\n<style>\nUsage\nRendering an inline CSS stylesheet\nReference\n<style>\nTo add inline styles to your document, render the\nbuilt-in browser\n<style>\ncomponent\n. You can render\n<style>\nfrom any component and React will\nin certain cases\nplace the corresponding DOM element in the document head and de-duplicate identical styles.\n<\nstyle\n>\n{\n` p { color: red; } `\n}\n</\nstyle\n>\nSee more examples below.\nProps\n<style>\nsupports all\ncommon element props.\nchildren\n: a string, required. The contents of the stylesheet.\nprecedence\n: a string. Tells React where to rank the\n<style>\nDOM node relative to others in the document\n<head>\n, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are ‚Äúlower‚Äù and precedence values it discovers later are ‚Äúhigher‚Äù. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are\n<link>\nor inline\n<style>\ntags or loaded using\npreinit\nfunctions.\nhref\n: a string. Allows React to\nde-duplicate styles\nthat have the same\nhref\n.\nmedia\n: a string. Restricts the stylesheet to a certain\nmedia query\n.\nnonce\n: a string. A cryptographic\nnonce to allow the resource\nwhen using a strict Content Security Policy.\ntitle\n: a string. Specifies the name of an\nalternative stylesheet\n.\nProps that are\nnot recommended\nfor use with React:\nblocking\n: a string. If set to\n\"render\"\n, instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\nSpecial rendering behavior\nReact can move\n<style>\ncomponents to the document‚Äôs\n<head>\n, de-duplicate identical stylesheets, and\nsuspend\nwhile the stylesheet is loading.\nTo opt into this behavior, provide the\nhref\nand\nprecedence\nprops. React will de-duplicate styles if they have the same\nhref\n. The precedence prop tells React where to rank the\n<style>\nDOM node relative to others in the document\n<head>\n, which determines which stylesheet can override the other.\nThis special treatment comes with two caveats:\nReact will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)\nReact will drop all extraneous props when using the\nprecedence\nprop (beyond\nhref\nand\nprecedence\n).\nReact may leave the style in the DOM even after the component that rendered it has been unmounted.\nUsage\nRendering an inline CSS stylesheet\nIf a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.\nThe\nhref\nprop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same\nhref\n.\nIf you supply a\nprecedence\nprop, React will reorder inline stylesheets based on the order these values appear in the component tree.\nInline stylesheets will not trigger Suspense boundaries while they‚Äôre loading.\nEven if they load async resources like fonts or images.\nApp.js\nShowRenderedHTML.js\nApp.js\nReset\nFork\nimport\nShowRenderedHTML\nfrom\n'./ShowRenderedHTML.js'\n;\nimport\n{\nuseId\n}\nfrom\n'react'\n;\nfunction\nPieChart\n(\n{\ndata\n,\ncolors\n}\n)\n{\nconst\nid\n=\nuseId\n(\n)\n;\nconst\nstylesheet\n=\ncolors\n.\nmap\n(\n(\ncolor\n,\nindex\n)\n=>\n`#\n${\nid\n}\n.color-\n${\nindex\n}\n: \\{ color: \"\n${\ncolor\n}\n\"; \\}`\n)\n.\njoin\n(\n)\n;\nreturn\n(\n<\n>\n<\nstyle\nhref\n=\n{\n\"PieChart-\"\n+\nJSON\n.\nstringify\n(\ncolors\n)\n}\nprecedence\n=\n\"medium\"\n>\n{\nstylesheet\n}\n</\nstyle\n>\n<\nsvg\nid\n=\n{\nid\n}\n>\n‚Ä¶\n</\nsvg\n>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nreturn\n(\n<\nShowRenderedHTML\n>\n<\nPieChart\ndata\n=\n\"...\"\ncolors\n=\n{\n[\n'red'\n,\n'green'\n,\n'blue'\n]\n}\n/>\n</\nShowRenderedHTML\n>\n)\n;\n}\nShow more\nPrevious\n<script>\nNext\n<title>",
    "url": "https://react.dev/reference/react-dom/components/style",
    "source": "react",
    "doc_type": "api_reference",
    "scraped_at": 12306.3627664
  },
  {
    "title": "Add React to an Existing Project",
    "content": "Learn React\nInstallation\nAdd React to an Existing Project\nIf you want to add some interactivity to your existing project, you don‚Äôt have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere.\nNote\nYou need to install\nNode.js\nfor local development.\nAlthough you can\ntry React\nonline or with a simple HTML page, realistically most JavaScript tooling you‚Äôll want to use for development requires Node.js.\nUsing React for an entire subroute of your existing website\nLet‚Äôs say you have an existing web app at\nexample.com\nbuilt with another server technology (like Rails), and you want to implement all routes starting with\nexample.com/some-app/\nfully with React.\nHere‚Äôs how we recommend to set it up:\nBuild the React part of your app\nusing one of the\nReact-based frameworks\n.\nSpecify\n/some-app\nas the\nbase path\nin your framework‚Äôs configuration (here‚Äôs how:\nNext.js\n,\nGatsby\n).\nConfigure your server or a proxy\nso that all requests under\n/some-app/\nare handled by your React app.\nThis ensures the React part of your app can\nbenefit from the best practices\nbaked into those frameworks.\nMany React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can‚Äôt or don‚Äôt want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (\nnext export\noutput\nfor Next.js, default for Gatsby) at\n/some-app/\ninstead.\nUsing React for a part of your existing page\nLet‚Äôs say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That‚Äôs a common way to integrate React‚Äîin fact, it‚Äôs how most React usage looked at Meta for many years!\nYou can do this in two steps:\nSet up a JavaScript environment\nthat lets you use the\nJSX syntax\n, split your code into modules with the\nimport\n/\nexport\nsyntax, and use packages (for example, React) from the\nnpm\npackage registry.\nRender your React components\nwhere you want to see them on the page.\nThe exact approach depends on your existing page setup, so let‚Äôs walk through some details.\nStep 1: Set up a modular JavaScript environment\nA modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the\nnpm\nregistry‚Äîincluding React itself! How you do this depends on your existing setup:\nIf your app is already split into files that use\nimport\nstatements,\ntry to use the setup you already have. Check whether writing\n<div />\nin your JS code causes a syntax error. If it causes a syntax error, you might need to\ntransform your JavaScript code with Babel\n, and enable the\nBabel React preset\nto use JSX.\nIf your app doesn‚Äôt have an existing setup for compiling JavaScript modules,\nset it up with\nVite\n. The Vite community maintains\nmany integrations with backend frameworks\n, including Rails, Django, and Laravel. If your backend framework is not listed,\nfollow this guide\nto manually integrate Vite builds with your backend.\nTo check whether your setup works, run this command in your project folder:\nTerminal\nCopy\nnpm install react react-dom\nThen add these lines of code at the top of your main JavaScript file (it might be called\nindex.js\nor\nmain.js\n):\nindex.js\nindex.js\nReset\nFork\nimport\n{\ncreateRoot\n}\nfrom\n'react-dom/client'\n;\n// Clear the existing HTML content\ndocument\n.\nbody\n.\ninnerHTML\n=\n'<div id=\"app\"></div>'\n;\n// Render your React component instead\nconst\nroot\n=\ncreateRoot\n(\ndocument\n.\ngetElementById\n(\n'app'\n)\n)\n;\nroot\n.\nrender\n(\n<\nh1\n>\nHello, world\n</\nh1\n>\n)\n;\nIf the entire content of your page was replaced by a ‚ÄúHello, world!‚Äù, everything worked! Keep reading.\nNote\nIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it‚Äôs worth it! If you get stuck, try our\ncommunity resources\nor the\nVite Chat\n.\nStep 2: Render React components anywhere on the page\nIn the previous step, you put this code at the top of your main file:\nimport\n{\ncreateRoot\n}\nfrom\n'react-dom/client'\n;\n// Clear the existing HTML content\ndocument\n.\nbody\n.\ninnerHTML\n=\n'<div id=\"app\"></div>'\n;\n// Render your React component instead\nconst\nroot\n=\ncreateRoot\n(\ndocument\n.\ngetElementById\n(\n'app'\n)\n)\n;\nroot\n.\nrender\n(\n<\nh1\n>\nHello, world\n</\nh1\n>\n)\n;\nOf course, you don‚Äôt actually want to clear the existing HTML content!\nDelete this code.\nInstead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique\nid\nattribute to any tag, for example:\n<!-- ... somewhere in your html ... -->\n<\nnav\nid\n=\n\"navigation\"\n>\n</\nnav\n>\n<!-- ... more html ... -->\nThis lets you find that HTML element with\ndocument.getElementById\nand pass it to\ncreateRoot\nso that you can render your own React component inside:\nindex.js\nindex.html\nindex.js\nReset\nFork\nimport\n{\ncreateRoot\n}\nfrom\n'react-dom/client'\n;\nfunction\nNavigationBar\n(\n)\n{\n// TODO: Actually implement a navigation bar\nreturn\n<\nh1\n>\nHello from React!\n</\nh1\n>\n;\n}\nconst\ndomNode\n=\ndocument\n.\ngetElementById\n(\n'navigation'\n)\n;\nconst\nroot\n=\ncreateRoot\n(\ndomNode\n)\n;\nroot\n.\nrender\n(\n<\nNavigationBar\n/>\n)\n;\nNotice how the original HTML content from\nindex.html\nis preserved, but your own\nNavigationBar\nReact component now appears inside the\n<nav id=\"navigation\">\nfrom your HTML. Read the\ncreateRoot\nusage documentation\nto learn more about rendering React components inside an existing HTML page.\nWhen you adopt React in an existing project, it‚Äôs common to start with small interactive components (like buttons), and then gradually keep ‚Äúmoving upwards‚Äù until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to\na React framework\nright after to get the most out of React.\nUsing React Native in an existing native mobile app\nReact Native\ncan also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift),\nfollow this guide\nto add a React Native screen to it.\nPrevious\nBuild a React App from Scratch\nNext\nSetup",
    "url": "https://react.dev/learn/add-react-to-an-existing-project",
    "source": "react",
    "doc_type": "tutorial",
    "scraped_at": 12306.5714864
  },
  {
    "title": "memo",
    "content": "API Reference\nAPIs\nmemo\nmemo\nlets you skip re-rendering a component when its props are unchanged.\nconst\nMemoizedComponent\n=\nmemo\n(\nSomeComponent\n,\narePropsEqual\n?\n)\nNote\nReact Compiler\nautomatically applies the equivalent of\nmemo\nto all components, reducing the need for manual memoization. You can use the compiler to handle component memoization automatically.\nReference\nmemo(Component, arePropsEqual?)\nUsage\nSkipping re-rendering when props are unchanged\nUpdating a memoized component using state\nUpdating a memoized component using a context\nMinimizing props changes\nSpecifying a custom comparison function\nDo I still need React.memo if I use React Compiler?\nTroubleshooting\nMy component re-renders when a prop is an object, array, or function\nReference\nmemo(Component, arePropsEqual?)\nWrap a component in\nmemo\nto get a\nmemoized\nversion of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.\nimport\n{\nmemo\n}\nfrom\n'react'\n;\nconst\nSomeComponent\n=\nmemo\n(\nfunction\nSomeComponent\n(\nprops\n)\n{\n// ...\n}\n)\n;\nSee more examples below.\nParameters\nComponent\n: The component that you want to memoize. The\nmemo\ndoes not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and\nforwardRef\ncomponents, is accepted.\noptional\narePropsEqual\n: A function that accepts two arguments: the component‚Äôs previous props, and its new props. It should return\ntrue\nif the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return\nfalse\n. Usually, you will not specify this function. By default, React will compare each prop with\nObject.is\n.\nReturns\nmemo\nreturns a new React component. It behaves the same as the component provided to\nmemo\nexcept that React will not always re-render it when its parent is being re-rendered unless its props have changed.\nUsage\nSkipping re-rendering when props are unchanged\nReact normally re-renders a component whenever its parent re-renders. With\nmemo\n, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be\nmemoized\n.\nTo memoize a component, wrap it in\nmemo\nand use the value that it returns in place of your original component:\nconst\nGreeting\n=\nmemo\n(\nfunction\nGreeting\n(\n{\nname\n}\n)\n{\nreturn\n<\nh1\n>\nHello,\n{\nname\n}\n!\n</\nh1\n>\n;\n}\n)\n;\nexport\ndefault\nGreeting\n;\nA React component should always have\npure rendering logic.\nThis means that it must return the same output if its props, state, and context haven‚Äôt changed. By using\nmemo\n, you are telling React that your component complies with this requirement, so React doesn‚Äôt need to re-render as long as its props haven‚Äôt changed. Even with\nmemo\n, your component will re-render if its own state changes or if a context that it‚Äôs using changes.\nIn this example, notice that the\nGreeting\ncomponent re-renders whenever\nname\nis changed (because that‚Äôs one of its props), but not when\naddress\nis changed (because it‚Äôs not passed to\nGreeting\nas a prop):\nApp.js\nApp.js\nReset\nFork\nimport\n{\nmemo\n,\nuseState\n}\nfrom\n'react'\n;\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nconst\n[\nname\n,\nsetName\n]\n=\nuseState\n(\n''\n)\n;\nconst\n[\naddress\n,\nsetAddress\n]\n=\nuseState\n(\n''\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nName\n{\n': '\n}\n<\ninput\nvalue\n=\n{\nname\n}\nonChange\n=\n{\ne\n=>\nsetName\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nlabel\n>\nAddress\n{\n': '\n}\n<\ninput\nvalue\n=\n{\naddress\n}\nonChange\n=\n{\ne\n=>\nsetAddress\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nGreeting\nname\n=\n{\nname\n}\n/>\n</\n>\n)\n;\n}\nconst\nGreeting\n=\nmemo\n(\nfunction\nGreeting\n(\n{\nname\n}\n)\n{\nconsole\n.\nlog\n(\n\"Greeting was rendered at\"\n,\nnew\nDate\n(\n)\n.\ntoLocaleTimeString\n(\n)\n)\n;\nreturn\n<\nh3\n>\nHello\n{\nname\n&&\n', '\n}\n{\nname\n}\n!\n</\nh3\n>\n;\n}\n)\n;\nShow more\nNote\nYou should only rely on\nmemo\nas a performance optimization.\nIf your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add\nmemo\nto improve performance.\nDeep Dive\nShould you add memo everywhere?\nShow Details\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\nOptimizing with\nmemo\nis only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders,\nmemo\nis unnecessary. Keep in mind that\nmemo\nis completely useless if the props passed to your component are\nalways different,\nsuch as if you pass an object or a plain function defined during rendering. This is why you will often need\nuseMemo\nand\nuseCallback\ntogether with\nmemo\n.\nThere is no benefit to wrapping a component in\nmemo\nin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that‚Äôs ‚Äúalways new‚Äù is enough to break memoization for an entire component.\nIn practice, you can make a lot of memoization unnecessary by following a few principles:\nWhen a component visually wraps other components, let it\naccept JSX as children.\nThis way, when the wrapper component updates its own state, React knows that its children don‚Äôt need to re-render.\nPrefer local state and don‚Äôt\nlift state up\nany further than necessary. For example, don‚Äôt keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\nKeep your\nrendering logic pure.\nIf re-rendering a component causes a problem or produces some noticeable visual artifact, it‚Äôs a bug in your component! Fix the bug instead of adding memoization.\nAvoid\nunnecessary Effects that update state.\nMost performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\nTry to\nremove unnecessary dependencies from your Effects.\nFor example, instead of memoization, it‚Äôs often simpler to move some object or a function inside an Effect or outside the component.\nIf a specific interaction still feels laggy,\nuse the React Developer Tools profiler\nto see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it‚Äôs good to follow them in any case. In the long term, we‚Äôre researching\ndoing granular memoization automatically\nto solve this once and for all.\nUpdating a memoized component using state\nEven when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.\nApp.js\nApp.js\nReset\nFork\nimport\n{\nmemo\n,\nuseState\n}\nfrom\n'react'\n;\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nconst\n[\nname\n,\nsetName\n]\n=\nuseState\n(\n''\n)\n;\nconst\n[\naddress\n,\nsetAddress\n]\n=\nuseState\n(\n''\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nName\n{\n': '\n}\n<\ninput\nvalue\n=\n{\nname\n}\nonChange\n=\n{\ne\n=>\nsetName\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nlabel\n>\nAddress\n{\n': '\n}\n<\ninput\nvalue\n=\n{\naddress\n}\nonChange\n=\n{\ne\n=>\nsetAddress\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nGreeting\nname\n=\n{\nname\n}\n/>\n</\n>\n)\n;\n}\nconst\nGreeting\n=\nmemo\n(\nfunction\nGreeting\n(\n{\nname\n}\n)\n{\nconsole\n.\nlog\n(\n'Greeting was rendered at'\n,\nnew\nDate\n(\n)\n.\ntoLocaleTimeString\n(\n)\n)\n;\nconst\n[\ngreeting\n,\nsetGreeting\n]\n=\nuseState\n(\n'Hello'\n)\n;\nreturn\n(\n<\n>\n<\nh3\n>\n{\ngreeting\n}\n{\nname\n&&\n', '\n}\n{\nname\n}\n!\n</\nh3\n>\n<\nGreetingSelector\nvalue\n=\n{\ngreeting\n}\nonChange\n=\n{\nsetGreeting\n}\n/>\n</\n>\n)\n;\n}\n)\n;\nfunction\nGreetingSelector\n(\n{\nvalue\n,\nonChange\n}\n)\n{\nreturn\n(\n<\n>\n<\nlabel\n>\n<\ninput\ntype\n=\n\"radio\"\nchecked\n=\n{\nvalue\n===\n'Hello'\n}\nonChange\n=\n{\ne\n=>\nonChange\n(\n'Hello'\n)\n}\n/>\nRegular greeting\n</\nlabel\n>\n<\nlabel\n>\n<\ninput\ntype\n=\n\"radio\"\nchecked\n=\n{\nvalue\n===\n'Hello and welcome'\n}\nonChange\n=\n{\ne\n=>\nonChange\n(\n'Hello and welcome'\n)\n}\n/>\nEnthusiastic greeting\n</\nlabel\n>\n</\n>\n)\n;\n}\nShow more\nIf you set a state variable to its current value, React will skip re-rendering your component even without\nmemo\n. You may still see your component function being called an extra time, but the result will be discarded.\nUpdating a memoized component using a context\nEven when a component is memoized, it will still re-render when a context that it‚Äôs using changes. Memoization only has to do with props that are passed to the component from its parent.\nApp.js\nApp.js\nReset\nFork\nimport\n{\ncreateContext\n,\nmemo\n,\nuseContext\n,\nuseState\n}\nfrom\n'react'\n;\nconst\nThemeContext\n=\ncreateContext\n(\nnull\n)\n;\nexport\ndefault\nfunction\nMyApp\n(\n)\n{\nconst\n[\ntheme\n,\nsetTheme\n]\n=\nuseState\n(\n'dark'\n)\n;\nfunction\nhandleClick\n(\n)\n{\nsetTheme\n(\ntheme\n===\n'dark'\n?\n'light'\n:\n'dark'\n)\n;\n}\nreturn\n(\n<\nThemeContext\nvalue\n=\n{\ntheme\n}\n>\n<\nbutton\nonClick\n=\n{\nhandleClick\n}\n>\nSwitch theme\n</\nbutton\n>\n<\nGreeting\nname\n=\n\"Taylor\"\n/>\n</\nThemeContext\n>\n)\n;\n}\nconst\nGreeting\n=\nmemo\n(\nfunction\nGreeting\n(\n{\nname\n}\n)\n{\nconsole\n.\nlog\n(\n\"Greeting was rendered at\"\n,\nnew\nDate\n(\n)\n.\ntoLocaleTimeString\n(\n)\n)\n;\nconst\ntheme\n=\nuseContext\n(\nThemeContext\n)\n;\nreturn\n(\n<\nh3\nclassName\n=\n{\ntheme\n}\n>\nHello,\n{\nname\n}\n!\n</\nh3\n>\n)\n;\n}\n)\n;\nShow more\nTo make your component re-render only when a\npart\nof some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.\nMinimizing props changes\nWhen you use\nmemo\n, your component re-renders whenever any prop is not\nshallowly equal\nto what it was previously. This means that React compares every prop in your component with its previous value using the\nObject.is\ncomparison. Note that\nObject.is(3, 3)\nis\ntrue\n, but\nObject.is({}, {})\nis\nfalse\n.\nTo get the most out of\nmemo\n, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using\nuseMemo\n:\nfunction\nPage\n(\n)\n{\nconst\n[\nname\n,\nsetName\n]\n=\nuseState\n(\n'Taylor'\n)\n;\nconst\n[\nage\n,\nsetAge\n]\n=\nuseState\n(\n42\n)\n;\nconst\nperson\n=\nuseMemo\n(\n(\n)\n=>\n(\n{\nname\n,\nage\n}\n)\n,\n[\nname\n,\nage\n]\n)\n;\nreturn\n<\nProfile\nperson\n=\n{\nperson\n}\n/>\n;\n}\nconst\nProfile\n=\nmemo\n(\nfunction\nProfile\n(\n{\nperson\n}\n)\n{\n// ...\n}\n)\n;\nA better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:\nfunction\nPage\n(\n)\n{\nconst\n[\nname\n,\nsetName\n]\n=\nuseState\n(\n'Taylor'\n)\n;\nconst\n[\nage\n,\nsetAge\n]\n=\nuseState\n(\n42\n)\n;\nreturn\n<\nProfile\nname\n=\n{\nname\n}\nage\n=\n{\nage\n}\n/>\n;\n}\nconst\nProfile\n=\nmemo\n(\nfunction\nProfile\n(\n{\nname\n,\nage\n}\n)\n{\n// ...\n}\n)\n;\nEven individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:\nfunction\nGroupsLanding\n(\n{\nperson\n}\n)\n{\nconst\nhasGroups\n=\nperson\n.\ngroups\n!==\nnull\n;\nreturn\n<\nCallToAction\nhasGroups\n=\n{\nhasGroups\n}\n/>\n;\n}\nconst\nCallToAction\n=\nmemo\n(\nfunction\nCallToAction\n(\n{\nhasGroups\n}\n)\n{\n// ...\n}\n)\n;\nWhen you need to pass a function to memoized component, either declare it outside your component so that it never changes, or\nuseCallback\nto cache its definition between re-renders.\nSpecifying a custom comparison function\nIn rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to\nmemo\n. It should return\ntrue\nonly if the new props would result in the same output as the old props; otherwise it should return\nfalse\n.\nconst\nChart\n=\nmemo\n(\nfunction\nChart\n(\n{\ndataPoints\n}\n)\n{\n// ...\n}\n,\narePropsEqual\n)\n;\nfunction\narePropsEqual\n(\noldProps\n,\nnewProps\n)\n{\nreturn\n(\noldProps\n.\ndataPoints\n.\nlength\n===\nnewProps\n.\ndataPoints\n.\nlength\n&&\noldProps\n.\ndataPoints\n.\nevery\n(\n(\noldPoint\n,\nindex\n)\n=>\n{\nconst\nnewPoint\n=\nnewProps\n.\ndataPoints\n[\nindex\n]\n;\nreturn\noldPoint\n.\nx\n===\nnewPoint\n.\nx\n&&\noldPoint\n.\ny\n===\nnewPoint\n.\ny\n;\n}\n)\n)\n;\n}\nIf you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.\nWhen you do performance measurements, make sure that React is running in the production mode.\nPitfall\nIf you provide a custom\narePropsEqual\nimplementation,\nyou must compare every prop, including functions.\nFunctions often\nclose over\nthe props and state of parent components. If you return\ntrue\nwhen\noldProps.onClick !== newProps.onClick\n, your component will keep ‚Äúseeing‚Äù the props and state from a previous render inside its\nonClick\nhandler, leading to very confusing bugs.\nAvoid doing deep equality checks inside\narePropsEqual\nunless you are 100% sure that the data structure you‚Äôre working with has a known limited depth.\nDeep equality checks can become incredibly slow\nand can freeze your app for many seconds if someone changes the data structure later.\nDo I still need React.memo if I use React Compiler?\nWhen you enable\nReact Compiler\n, you typically don‚Äôt need\nReact.memo\nanymore. The compiler automatically optimizes component re-rendering for you.\nHere‚Äôs how it works:\nWithout React Compiler\n, you need\nReact.memo\nto prevent unnecessary re-renders:\n// Parent re-renders every second\nfunction\nParent\n(\n)\n{\nconst\n[\nseconds\n,\nsetSeconds\n]\n=\nuseState\n(\n0\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\ninterval\n=\nsetInterval\n(\n(\n)\n=>\n{\nsetSeconds\n(\ns\n=>\ns\n+\n1\n)\n;\n}\n,\n1000\n)\n;\nreturn\n(\n)\n=>\nclearInterval\n(\ninterval\n)\n;\n}\n,\n[\n]\n)\n;\nreturn\n(\n<\n>\n<\nh1\n>\nSeconds:\n{\nseconds\n}\n</\nh1\n>\n<\nExpensiveChild\nname\n=\n\"John\"\n/>\n</\n>\n)\n;\n}\n// Without memo, this re-renders every second even though props don't change\nconst\nExpensiveChild\n=\nmemo\n(\nfunction\nExpensiveChild\n(\n{\nname\n}\n)\n{\nconsole\n.\nlog\n(\n'ExpensiveChild rendered'\n)\n;\nreturn\n<\ndiv\n>\nHello,\n{\nname\n}\n!\n</\ndiv\n>\n;\n}\n)\n;\nWith React Compiler enabled\n, the same optimization happens automatically:\n// No memo needed - compiler prevents re-renders automatically\nfunction\nExpensiveChild\n(\n{\nname\n}\n)\n{\nconsole\n.\nlog\n(\n'ExpensiveChild rendered'\n)\n;\nreturn\n<\ndiv\n>\nHello,\n{\nname\n}\n!\n</\ndiv\n>\n;\n}\nHere‚Äôs the key part of what the React Compiler generates:\nfunction\nParent\n(\n)\n{\nconst\n$\n=\n_c\n(\n7\n)\n;\nconst\n[\nseconds\n,\nsetSeconds\n]\n=\nuseState\n(\n0\n)\n;\n// ... other code ...\nlet\nt3\n;\nif\n(\n$\n[\n4\n]\n===\nSymbol\n.\nfor\n(\n\"react.memo_cache_sentinel\"\n)\n)\n{\nt3\n=\n<\nExpensiveChild\nname\n=\n\"John\"\n/>\n;\n$\n[\n4\n]\n=\nt3\n;\n}\nelse\n{\nt3\n=\n$\n[\n4\n]\n;\n}\n// ... return statement ...\n}\nNotice the highlighted lines: The compiler wraps\n<ExpensiveChild name=\"John\" />\nin a cache check. Since the\nname\nprop is always\n\"John\"\n, this JSX is created once and reused on every parent re-render. This is exactly what\nReact.memo\ndoes - it prevents the child from re-rendering when its props haven‚Äôt changed.\nThe React Compiler automatically:\nTracks that the\nname\nprop passed to\nExpensiveChild\nhasn‚Äôt changed\nReuses the previously created JSX for\n<ExpensiveChild name=\"John\" />\nSkips re-rendering\nExpensiveChild\nentirely\nThis means\nyou can safely remove\nReact.memo\nfrom your components when using React Compiler\n. The compiler provides the same optimization automatically, making your code cleaner and easier to maintain.\nNote\nThe compiler‚Äôs optimization is actually more comprehensive than\nReact.memo\n. It also memoizes intermediate values and expensive computations within your components, similar to combining\nReact.memo\nwith\nuseMemo\nthroughout your component tree.\nTroubleshooting\nMy component re-renders when a prop is an object, array, or function\nReact compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this,\nsimplify props or memoize props in the parent component\n.\nPrevious\nlazy\nNext\nstartTransition",
    "url": "https://react.dev/reference/react/memo",
    "source": "react",
    "doc_type": "api_reference",
    "scraped_at": 12306.7733284
  },
  {
    "title": "Editor Setup",
    "content": "Learn React\nSetup\nEditor Setup\nA properly configured editor can make code clearer to read and faster to write. It can even help you catch bugs as you write them! If this is your first time setting up an editor or you‚Äôre looking to tune up your current editor, we have a few recommendations.\nYou will learn\nWhat the most popular editors are\nHow to format your code automatically\nYour editor\nVS Code\nis one of the most popular editors in use today. It has a large marketplace of extensions and integrates well with popular services like GitHub. Most of the features listed below can be added to VS Code as extensions as well, making it highly configurable!\nOther popular text editors used in the React community include:\nWebStorm\nis an integrated development environment designed specifically for JavaScript.\nSublime Text\nhas support for JSX and TypeScript,\nsyntax highlighting\nand autocomplete built in.\nVim\nis a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as ‚Äúvi‚Äù with most UNIX systems and with Apple OS X.\nRecommended text editor features\nSome editors come with these features built in, but others might require adding an extension. Check to see what support your editor of choice provides to be sure!\nLinting\nCode linters find problems in your code as you write, helping you fix them early.\nESLint\nis a popular, open source linter for JavaScript.\nInstall ESLint with the recommended configuration for React\n(be sure you have\nNode installed!\n)\nIntegrate ESLint in VSCode with the official extension\nMake sure that you‚Äôve enabled all the\neslint-plugin-react-hooks\nrules for your project.\nThey are essential and catch the most severe bugs early. The recommended\neslint-config-react-app\npreset already includes them.\nFormatting\nThe last thing you want to do when sharing your code with another contributor is get into a discussion about\ntabs vs spaces\n! Fortunately,\nPrettier\nwill clean up your code by reformatting it to conform to preset, configurable rules. Run Prettier, and all your tabs will be converted to spaces‚Äîand your indentation, quotes, etc will also all be changed to conform to the configuration. In the ideal setup, Prettier will run when you save your file, quickly making these edits for you.\nYou can install the\nPrettier extension in VSCode\nby following these steps:\nLaunch VS Code\nUse Quick Open (press Ctrl/Cmd+P)\nPaste in\next install esbenp.prettier-vscode\nPress Enter\nFormatting on save\nIdeally, you should format your code on every save. VS Code has settings for this!\nIn VS Code, press\nCTRL/CMD + SHIFT + P\n.\nType ‚Äúsettings‚Äù\nHit Enter\nIn the search bar, type ‚Äúformat on save‚Äù\nBe sure the ‚Äúformat on save‚Äù option is ticked!\nIf your ESLint preset has formatting rules, they may conflict with Prettier. We recommend disabling all formatting rules in your ESLint preset using\neslint-config-prettier\nso that ESLint is\nonly\nused for catching logical mistakes. If you want to enforce that files are formatted before a pull request is merged, use\nprettier --check\nfor your continuous integration.\nPrevious\nSetup\nNext\nUsing TypeScript",
    "url": "https://react.dev/learn/editor-setup",
    "source": "react",
    "doc_type": "tutorial",
    "scraped_at": 12307.0390784
  },
  {
    "title": "Lifecycle of Reactive Effects",
    "content": "Learn React\nEscape Hatches\nLifecycle of Reactive Effects\nEffects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you‚Äôve specified your Effect‚Äôs dependencies correctly. This keeps your Effect synchronized to the latest props and state.\nYou will learn\nHow an Effect‚Äôs lifecycle is different from a component‚Äôs lifecycle\nHow to think about each individual Effect in isolation\nWhen your Effect needs to re-synchronize, and why\nHow your Effect‚Äôs dependencies are determined\nWhat it means for a value to be reactive\nWhat an empty dependency array means\nHow React verifies your dependencies are correct with a linter\nWhat to do when you disagree with the linter\nThe lifecycle of an Effect\nEvery React component goes through the same lifecycle:\nA component\nmounts\nwhen it‚Äôs added to the screen.\nA component\nupdates\nwhen it receives new props or state, usually in response to an interaction.\nA component\nunmounts\nwhen it‚Äôs removed from the screen.\nIt‚Äôs a good way to think about components, but\nnot\nabout Effects.\nInstead, try to think about each Effect independently from your component‚Äôs lifecycle. An Effect describes how to\nsynchronize an external system\nto the current props and state. As your code changes, synchronization will need to happen more or less often.\nTo illustrate this point, consider this Effect connecting your component to a chat server:\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n]\n)\n;\n// ...\n}\nYour Effect‚Äôs body specifies how to\nstart synchronizing:\n// ...\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n// ...\nThe cleanup function returned by your Effect specifies how to\nstop synchronizing:\n// ...\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n// ...\nIntuitively, you might think that React would\nstart synchronizing\nwhen your component mounts and\nstop synchronizing\nwhen your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to\nstart and stop synchronizing multiple times\nwhile the component remains mounted.\nLet‚Äôs look at\nwhy\nthis is necessary,\nwhen\nit happens, and\nhow\nyou can control this behavior.\nNote\nSome Effects don‚Äôt return a cleanup function at all.\nMore often than not,\nyou‚Äôll want to return one‚Äîbut if you don‚Äôt, React will behave as if you returned an empty cleanup function.\nWhy synchronization may need to happen more than once\nImagine this\nChatRoom\ncomponent receives a\nroomId\nprop that the user picks in a dropdown. Let‚Äôs say that initially the user picks the\n\"general\"\nroom as the\nroomId\n. Your app displays the\n\"general\"\nchat room:\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n/* \"general\" */\n}\n)\n{\n// ...\nreturn\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n;\n}\nAfter the UI is displayed, React will run your Effect to\nstart synchronizing.\nIt connects to the\n\"general\"\nroom:\nfunction\nChatRoom\n(\n{\nroomId\n/* \"general\" */\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// Connects to the \"general\" room\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n// Disconnects from the \"general\" room\n}\n;\n}\n,\n[\nroomId\n]\n)\n;\n// ...\nSo far, so good.\nLater, the user picks a different room in the dropdown (for example,\n\"travel\"\n). First, React will update the UI:\nfunction\nChatRoom\n(\n{\nroomId\n/* \"travel\" */\n}\n)\n{\n// ...\nreturn\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n;\n}\nThink about what should happen next. The user sees that\n\"travel\"\nis the selected chat room in the UI. However, the Effect that ran the last time is still connected to the\n\"general\"\nroom.\nThe\nroomId\nprop has changed, so what your Effect did back then (connecting to the\n\"general\"\nroom) no longer matches the UI.\nAt this point, you want React to do two things:\nStop synchronizing with the old\nroomId\n(disconnect from the\n\"general\"\nroom)\nStart synchronizing with the new\nroomId\n(connect to the\n\"travel\"\nroom)\nLuckily, you‚Äôve already taught React how to do both of these things!\nYour Effect‚Äôs body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let‚Äôs see how exactly that happens.\nHow React re-synchronizes your Effect\nRecall that your\nChatRoom\ncomponent has received a new value for its\nroomId\nprop. It used to be\n\"general\"\n, and now it is\n\"travel\"\n. React needs to re-synchronize your Effect to re-connect you to a different room.\nTo\nstop synchronizing,\nReact will call the cleanup function that your Effect returned after connecting to the\n\"general\"\nroom. Since\nroomId\nwas\n\"general\"\n, the cleanup function disconnects from the\n\"general\"\nroom:\nfunction\nChatRoom\n(\n{\nroomId\n/* \"general\" */\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// Connects to the \"general\" room\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n// Disconnects from the \"general\" room\n}\n;\n// ...\nThen React will run the Effect that you‚Äôve provided during this render. This time,\nroomId\nis\n\"travel\"\nso it will\nstart synchronizing\nto the\n\"travel\"\nchat room (until its cleanup function is eventually called too):\nfunction\nChatRoom\n(\n{\nroomId\n/* \"travel\" */\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// Connects to the \"travel\" room\nconnection\n.\nconnect\n(\n)\n;\n// ...\nThanks to this, you‚Äôre now connected to the same room that the user chose in the UI. Disaster averted!\nEvery time after your component re-renders with a different\nroomId\n, your Effect will re-synchronize. For example, let‚Äôs say the user changes\nroomId\nfrom\n\"travel\"\nto\n\"music\"\n. React will again\nstop synchronizing\nyour Effect by calling its cleanup function (disconnecting you from the\n\"travel\"\nroom). Then it will\nstart synchronizing\nagain by running its body with the new\nroomId\nprop (connecting you to the\n\"music\"\nroom).\nFinally, when the user goes to a different screen,\nChatRoom\nunmounts. Now there is no need to stay connected at all. React will\nstop synchronizing\nyour Effect one last time and disconnect you from the\n\"music\"\nchat room.\nThinking from the Effect‚Äôs perspective\nLet‚Äôs recap everything that‚Äôs happened from the\nChatRoom\ncomponent‚Äôs perspective:\nChatRoom\nmounted with\nroomId\nset to\n\"general\"\nChatRoom\nupdated with\nroomId\nset to\n\"travel\"\nChatRoom\nupdated with\nroomId\nset to\n\"music\"\nChatRoom\nunmounted\nDuring each of these points in the component‚Äôs lifecycle, your Effect did different things:\nYour Effect connected to the\n\"general\"\nroom\nYour Effect disconnected from the\n\"general\"\nroom and connected to the\n\"travel\"\nroom\nYour Effect disconnected from the\n\"travel\"\nroom and connected to the\n\"music\"\nroom\nYour Effect disconnected from the\n\"music\"\nroom\nNow let‚Äôs think about what happened from the perspective of the Effect itself:\nuseEffect\n(\n(\n)\n=>\n{\n// Your Effect connected to the room specified with roomId...\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\n// ...until it disconnected\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n]\n)\n;\nThis code‚Äôs structure might inspire you to see what happened as a sequence of non-overlapping time periods:\nYour Effect connected to the\n\"general\"\nroom (until it disconnected)\nYour Effect connected to the\n\"travel\"\nroom (until it disconnected)\nYour Effect connected to the\n\"music\"\nroom (until it disconnected)\nPreviously, you were thinking from the component‚Äôs perspective. When you looked from the component‚Äôs perspective, it was tempting to think of Effects as ‚Äúcallbacks‚Äù or ‚Äúlifecycle events‚Äù that fire at a specific time like ‚Äúafter a render‚Äù or ‚Äúbefore unmount‚Äù. This way of thinking gets complicated very fast, so it‚Äôs best to avoid.\nInstead, always focus on a single start/stop cycle at a time. It shouldn‚Äôt matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it‚Äôs needed.\nThis might remind you how you don‚Äôt think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and React\nfigures out the rest.\nHow React verifies that your Effect can re-synchronize\nHere is a live example that you can play with. Press ‚ÄúOpen chat‚Äù to mount the\nChatRoom\ncomponent:\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\nroomId\n]\n)\n;\nreturn\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nconst\n[\nshow\n,\nsetShow\n]\n=\nuseState\n(\nfalse\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nbutton\nonClick\n=\n{\n(\n)\n=>\nsetShow\n(\n!\nshow\n)\n}\n>\n{\nshow\n?\n'Close chat'\n:\n'Open chat'\n}\n</\nbutton\n>\n{\nshow\n&&\n<\nhr\n/>\n}\n{\nshow\n&&\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n}\n</\n>\n)\n;\n}\nShow more\nNotice that when the component mounts for the first time, you see three logs:\n‚úÖ Connecting to \"general\" room at https://localhost:1234...\n(development-only)\n‚ùå Disconnected from \"general\" room at https://localhost:1234.\n(development-only)\n‚úÖ Connecting to \"general\" room at https://localhost:1234...\nThe first two logs are development-only. In development, React always remounts each component once.\nReact verifies that your Effect can re-synchronize by forcing it to do that immediately in development.\nThis might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to check\nyou‚Äôve implemented its cleanup well.\nThe main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when the\nroomId\nchanges, your Effect re-synchronizes.\nHowever, there are also more unusual cases in which re-synchronization is necessary. For example, try editing the\nserverUrl\nin the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization.\nHow React knows that it needs to re-synchronize the Effect\nYou might be wondering how React knew that your Effect needed to re-synchronize after\nroomId\nchanges. It‚Äôs because\nyou told React\nthat its code depends on\nroomId\nby including it in the\nlist of dependencies:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\n// The roomId prop may change over time\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// This Effect reads roomId\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n]\n)\n;\n// So you tell React that this Effect \"depends on\" roomId\n// ...\nHere‚Äôs how this works:\nYou knew\nroomId\nis a prop, which means it can change over time.\nYou knew that your Effect reads\nroomId\n(so its logic depends on a value that may change later).\nThis is why you specified it as your Effect‚Äôs dependency (so that it re-synchronizes when\nroomId\nchanges).\nEvery time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect.\nFor example, if you passed\n[\"general\"]\nduring the initial render, and later you passed\n[\"travel\"]\nduring the next render, React will compare\n\"general\"\nand\n\"travel\"\n. These are different values (compared with\nObject.is\n), so React will re-synchronize your Effect. On the other hand, if your component re-renders but\nroomId\nhas not changed, your Effect will remain connected to the same room.\nEach Effect represents a separate synchronization process\nResist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let‚Äôs say you want to send an analytics event when the user visits the room. You already have an Effect that depends on\nroomId\n, so you might feel tempted to add the analytics call there:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nlogVisit\n(\nroomId\n)\n;\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n]\n)\n;\n// ...\n}\nBut imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call\nlogVisit(roomId)\nfor the same room, which you did not intend. Logging the visit\nis a separate process\nfrom connecting. Write them as two separate Effects:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nlogVisit\n(\nroomId\n)\n;\n}\n,\n[\nroomId\n]\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// ...\n}\n,\n[\nroomId\n]\n)\n;\n// ...\n}\nEach Effect in your code should represent a separate and independent synchronization process.\nIn the above example, deleting one Effect wouldn‚Äôt break the other Effect‚Äôs logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look ‚Äúcleaner‚Äù but will be\nmore difficult to maintain.\nThis is why you should think whether the processes are same or separate, not whether the code looks cleaner.\nEffects ‚Äúreact‚Äù to reactive values\nYour Effect reads two variables (\nserverUrl\nand\nroomId\n), but you only specified\nroomId\nas a dependency:\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n]\n)\n;\n// ...\n}\nWhy doesn‚Äôt\nserverUrl\nneed to be a dependency?\nThis is because the\nserverUrl\nnever changes due to a re-render. It‚Äôs always the same no matter how many times the component re-renders and why. Since\nserverUrl\nnever changes, it wouldn‚Äôt make sense to specify it as a dependency. After all, dependencies only do something when they change over time!\nOn the other hand,\nroomId\nmay be different on a re-render.\nProps, state, and other values declared inside the component are\nreactive\nbecause they‚Äôre calculated during rendering and participate in the React data flow.\nIf\nserverUrl\nwas a state variable, it would be reactive. Reactive values must be included in dependencies:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\n// Props change over time\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\n// State may change over time\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// Your Effect reads props and state\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n,\nserverUrl\n]\n)\n;\n// So you tell React that this Effect \"depends on\" on props and state\n// ...\n}\nBy including\nserverUrl\nas a dependency, you ensure that the Effect re-synchronizes after it changes.\nTry changing the selected chat room or edit the server URL in this sandbox:\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\nroomId\n,\nserverUrl\n]\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nServer URL:\n{\n' '\n}\n<\ninput\nvalue\n=\n{\nserverUrl\n}\nonChange\n=\n{\ne\n=>\nsetServerUrl\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nhr\n/>\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n</\n>\n)\n;\n}\nShow more\nWhenever you change a reactive value like\nroomId\nor\nserverUrl\n, the Effect re-connects to the chat server.\nWhat an Effect with empty dependencies means\nWhat happens if you move both\nserverUrl\nand\nroomId\noutside the component?\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nconst\nroomId\n=\n'general'\n;\nfunction\nChatRoom\n(\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nNow your Effect‚Äôs code does not use\nany\nreactive values, so its dependencies can be empty (\n[]\n).\nThinking from the component‚Äôs perspective, the empty\n[]\ndependency array means this Effect connects to the chat room only when the component mounts, and disconnects only when the component unmounts. (Keep in mind that React would still\nre-synchronize it an extra time\nin development to stress-test your logic.)\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nconst\nroomId\n=\n'general'\n;\nfunction\nChatRoom\n(\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\n]\n)\n;\nreturn\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nshow\n,\nsetShow\n]\n=\nuseState\n(\nfalse\n)\n;\nreturn\n(\n<\n>\n<\nbutton\nonClick\n=\n{\n(\n)\n=>\nsetShow\n(\n!\nshow\n)\n}\n>\n{\nshow\n?\n'Close chat'\n:\n'Open chat'\n}\n</\nbutton\n>\n{\nshow\n&&\n<\nhr\n/>\n}\n{\nshow\n&&\n<\nChatRoom\n/>\n}\n</\n>\n)\n;\n}\nShow more\nHowever, if you\nthink from the Effect‚Äôs perspective,\nyou don‚Äôt need to think about mounting and unmounting at all. What‚Äôs important is you‚Äôve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to change\nroomId\nor\nserverUrl\nover time (and they would become reactive), your Effect‚Äôs code won‚Äôt change. You will only need to add them to the dependencies.\nAll variables declared in the component body are reactive\nProps and state aren‚Äôt the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list.\nLet‚Äôs say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you‚Äôve already put the settings state in a\ncontext\nso you read the\nsettings\nfrom that context. Now you calculate the\nserverUrl\nbased on the selected server from props and the default server:\nfunction\nChatRoom\n(\n{\nroomId\n,\nselectedServerUrl\n}\n)\n{\n// roomId is reactive\nconst\nsettings\n=\nuseContext\n(\nSettingsContext\n)\n;\n// settings is reactive\nconst\nserverUrl\n=\nselectedServerUrl\n??\nsettings\n.\ndefaultServerUrl\n;\n// serverUrl is reactive\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\n// Your Effect reads roomId and serverUrl\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nroomId\n,\nserverUrl\n]\n)\n;\n// So it needs to re-synchronize when either of them changes!\n// ...\n}\nIn this example,\nserverUrl\nis not a prop or a state variable. It‚Äôs a regular variable that you calculate during rendering. But it‚Äôs calculated during rendering, so it can change due to a re-render. This is why it‚Äôs reactive.\nAll values inside the component (including props, state, and variables in your component‚Äôs body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect‚Äôs dependencies.\nIn other words, Effects ‚Äúreact‚Äù to all values from the component body.\nDeep Dive\nCan global or mutable values be dependencies?\nShow Details\nMutable values (including global variables) aren‚Äôt reactive.\nA mutable value like\nlocation.pathname\ncan‚Äôt be a dependency.\nIt‚Äôs mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn‚Äôt trigger a re-render of your component. Therefore, even if you specified it in the dependencies, React\nwouldn‚Äôt know\nto re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breaks\npurity of rendering.\nInstead, you should read and subscribe to an external mutable value with\nuseSyncExternalStore\n.\nA mutable value like\nref.current\nor things you read from it also can‚Äôt be a dependency.\nThe ref object returned by\nuseRef\nitself can be a dependency, but its\ncurrent\nproperty is intentionally mutable. It lets you\nkeep track of something without triggering a re-render.\nBut since changing it doesn‚Äôt trigger a re-render, it‚Äôs not a reactive value, and React won‚Äôt know to re-run your Effect when it changes.\nAs you‚Äôll learn below on this page, a linter will check for these issues automatically.\nReact verifies that you specified every reactive value as a dependency\nIf your linter is\nconfigured for React,\nit will check that every reactive value used by your Effect‚Äôs code is declared as its dependency. For example, this is a lint error because both\nroomId\nand\nserverUrl\nare reactive:\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\n// roomId is reactive\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\n// serverUrl is reactive\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n,\n[\n]\n)\n;\n// <-- Something's wrong here!\nreturn\n(\n<\n>\n<\nlabel\n>\nServer URL:\n{\n' '\n}\n<\ninput\nvalue\n=\n{\nserverUrl\n}\nonChange\n=\n{\ne\n=>\nsetServerUrl\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\nlabel\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nhr\n/>\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n</\n>\n)\n;\n}\nShow more\nThis may look like a React error, but really React is pointing out a bug in your code. Both\nroomId\nand\nserverUrl\nmay change over time, but you‚Äôre forgetting to re-synchronize your Effect when they change. You will remain connected to the initial\nroomId\nand\nserverUrl\neven after the user picks different values in the UI.\nTo fix the bug, follow the linter‚Äôs suggestion to specify\nroomId\nand\nserverUrl\nas dependencies of your Effect:\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\n// roomId is reactive\nconst\n[\nserverUrl\n,\nsetServerUrl\n]\n=\nuseState\n(\n'https://localhost:1234'\n)\n;\n// serverUrl is reactive\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\nserverUrl\n,\nroomId\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nTry this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed.\nNote\nIn some cases, React\nknows\nthat a value never changes even though it‚Äôs declared inside the component. For example, the\nset\nfunction\nreturned from\nuseState\nand the ref object returned by\nuseRef\nare\nstable\n‚Äîthey are guaranteed to not change on a re-render. Stable values aren‚Äôt reactive, so you may omit them from the list. Including them is allowed: they won‚Äôt change, so it doesn‚Äôt matter.\nWhat to do when you don‚Äôt want to re-synchronize\nIn the previous example, you‚Äôve fixed the lint error by listing\nroomId\nand\nserverUrl\nas dependencies.\nHowever, you could instead ‚Äúprove‚Äù to the linter that these values aren‚Äôt reactive values,\ni.e. that they\ncan‚Äôt\nchange as a result of a re-render. For example, if\nserverUrl\nand\nroomId\ndon‚Äôt depend on rendering and always have the same values, you can move them outside the component. Now they don‚Äôt need to be dependencies:\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\n// serverUrl is not reactive\nconst\nroomId\n=\n'general'\n;\n// roomId is not reactive\nfunction\nChatRoom\n(\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nYou can also move them\ninside the Effect.\nThey aren‚Äôt calculated during rendering, so they‚Äôre not reactive:\nfunction\nChatRoom\n(\n)\n{\nuseEffect\n(\n(\n)\n=>\n{\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\n// serverUrl is not reactive\nconst\nroomId\n=\n'general'\n;\n// roomId is not reactive\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\n{\nconnection\n.\ndisconnect\n(\n)\n;\n}\n;\n}\n,\n[\n]\n)\n;\n// ‚úÖ All dependencies declared\n// ...\n}\nEffects are reactive blocks of code.\nThey re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary.\nYou can‚Äôt ‚Äúchoose‚Äù your dependencies.\nYour dependencies must include every\nreactive value\nyou read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don‚Äôt fix these problems by suppressing the linter! Here‚Äôs what to try instead:\nCheck that your Effect represents an independent synchronization process.\nIf your Effect doesn‚Äôt synchronize anything,\nit might be unnecessary.\nIf it synchronizes several independent things,\nsplit it up.\nIf you want to read the latest value of props or state without ‚Äúreacting‚Äù to it and re-synchronizing the Effect,\nyou can split your Effect into a reactive part (which you‚Äôll keep in the Effect) and a non-reactive part (which you‚Äôll extract into something called an\nEffect Event\n).\nRead about separating Events from Effects.\nAvoid relying on objects and functions as dependencies.\nIf you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time.\nRead more about removing unnecessary dependencies from Effects.\nPitfall\nThe linter is your friend, but its powers are limited. The linter only knows when the dependencies are\nwrong\n. It doesn‚Äôt know\nthe best\nway to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn‚Äôt mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn‚Äôt reactive and doesn‚Äôt\nneed\nto be a dependency.\nIf you have an existing codebase, you might have some Effects that suppress the linter like this:\nuseEffect\n(\n(\n)\n=>\n{\n// ...\n// üî¥ Avoid suppressing the linter like this:\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n}\n,\n[\n]\n)\n;\nOn the\nnext\npages\n, you‚Äôll learn how to fix this code without breaking the rules. It‚Äôs always worth fixing!\nRecap\nComponents can mount, update, and unmount.\nEach Effect has a separate lifecycle from the surrounding component.\nEach Effect describes a separate synchronization process that can\nstart\nand\nstop\n.\nWhen you write and read Effects, think from each individual Effect‚Äôs perspective (how to start and stop synchronization) rather than from the component‚Äôs perspective (how it mounts, updates, or unmounts).\nValues declared inside the component body are ‚Äúreactive‚Äù.\nReactive values should re-synchronize the Effect because they can change over time.\nThe linter verifies that all reactive values used inside the Effect are specified as dependencies.\nAll errors flagged by the linter are legitimate. There‚Äôs always a way to fix the code to not break the rules.\nTry out some challenges\n1\n.\nFix reconnecting on every keystroke\n2\n.\nSwitch synchronization on and off\n3\n.\nInvestigate a stale value bug\n4\n.\nFix a connection switch\n5\n.\nPopulate a chain of select boxes\nChallenge\n1\nof\n5\n:\nFix reconnecting on every keystroke\nIn this example, the\nChatRoom\ncomponent connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working.\nHowever, there is a problem. Whenever you type into the message box input at the bottom,\nChatRoom\nalso\nreconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesn‚Äôt happen.\nApp.js\nchat.js\nApp.js\nReset\nFork\nimport\n{\nuseState\n,\nuseEffect\n}\nfrom\n'react'\n;\nimport\n{\ncreateConnection\n}\nfrom\n'./chat.js'\n;\nconst\nserverUrl\n=\n'https://localhost:1234'\n;\nfunction\nChatRoom\n(\n{\nroomId\n}\n)\n{\nconst\n[\nmessage\n,\nsetMessage\n]\n=\nuseState\n(\n''\n)\n;\nuseEffect\n(\n(\n)\n=>\n{\nconst\nconnection\n=\ncreateConnection\n(\nserverUrl\n,\nroomId\n)\n;\nconnection\n.\nconnect\n(\n)\n;\nreturn\n(\n)\n=>\nconnection\n.\ndisconnect\n(\n)\n;\n}\n)\n;\nreturn\n(\n<\n>\n<\nh1\n>\nWelcome to the\n{\nroomId\n}\nroom!\n</\nh1\n>\n<\ninput\nvalue\n=\n{\nmessage\n}\nonChange\n=\n{\ne\n=>\nsetMessage\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n/>\n</\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n[\nroomId\n,\nsetRoomId\n]\n=\nuseState\n(\n'general'\n)\n;\nreturn\n(\n<\n>\n<\nlabel\n>\nChoose the chat room:\n{\n' '\n}\n<\nselect\nvalue\n=\n{\nroomId\n}\nonChange\n=\n{\ne\n=>\nsetRoomId\n(\ne\n.\ntarget\n.\nvalue\n)\n}\n>\n<\noption\nvalue\n=\n\"general\"\n>\ngeneral\n</\noption\n>\n<\noption\nvalue\n=\n\"travel\"\n>\ntravel\n</\noption\n>\n<\noption\nvalue\n=\n\"music\"\n>\nmusic\n</\noption\n>\n</\nselect\n>\n</\nlabel\n>\n<\nhr\n/>\n<\nChatRoom\nroomId\n=\n{\nroomId\n}\n/>\n</\n>\n)\n;\n}\nShow more\nShow hint\nShow solution\nNext\nChallenge\nPrevious\nYou Might Not Need an Effect\nNext\nSeparating Events from Effects",
    "url": "https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values",
    "source": "react",
    "doc_type": "tutorial",
    "scraped_at": 12307.314961
  },
  {
    "title": "useFormStatus",
    "content": "API Reference\nHooks\nuseFormStatus\nuseFormStatus\nis a Hook that gives you status information of the last form submission.\nconst\n{\npending\n,\ndata\n,\nmethod\n,\naction\n}\n=\nuseFormStatus\n(\n)\n;\nReference\nuseFormStatus()\nUsage\nDisplay a pending state during form submission\nRead the form data being submitted\nTroubleshooting\nstatus.pending\nis never\ntrue\nReference\nuseFormStatus()\nThe\nuseFormStatus\nHook provides status information of the last form submission.\nimport\n{\nuseFormStatus\n}\nfrom\n\"react-dom\"\n;\nimport\naction\nfrom\n'./actions'\n;\nfunction\nSubmit\n(\n)\n{\nconst\nstatus\n=\nuseFormStatus\n(\n)\n;\nreturn\n<\nbutton\ndisabled\n=\n{\nstatus.pending\n}\n>\nSubmit\n</\nbutton\n>\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nreturn\n(\n<\nform\naction\n=\n{\naction\n}\n>\n<\nSubmit\n/>\n</\nform\n>\n)\n;\n}\nTo get status information, the\nSubmit\ncomponent must be rendered within a\n<form>\n. The Hook returns information like the\npending\nproperty which tells you if the form is actively submitting.\nIn the above example,\nSubmit\nuses this information to disable\n<button>\npresses while the form is submitting.\nSee more examples below.\nParameters\nuseFormStatus\ndoes not take any parameters.\nReturns\nA\nstatus\nobject with the following properties:\npending\n: A boolean. If\ntrue\n, this means the parent\n<form>\nis pending submission. Otherwise,\nfalse\n.\ndata\n: An object implementing the\nFormData interface\nthat contains the data the parent\n<form>\nis submitting. If there is no active submission or no parent\n<form>\n, it will be\nnull\n.\nmethod\n: A string value of either\n'get'\nor\n'post'\n. This represents whether the parent\n<form>\nis submitting with either a\nGET\nor\nPOST\nHTTP method\n. By default, a\n<form>\nwill use the\nGET\nmethod and can be specified by the\nmethod\nproperty.\naction\n: A reference to the function passed to the\naction\nprop on the parent\n<form>\n. If there is no parent\n<form>\n, the property is\nnull\n. If there is a URI value provided to the\naction\nprop, or no\naction\nprop specified,\nstatus.action\nwill be\nnull\n.\nCaveats\nThe\nuseFormStatus\nHook must be called from a component that is rendered inside a\n<form>\n.\nuseFormStatus\nwill only return status information for a parent\n<form>\n. It will not return status information for any\n<form>\nrendered in that same component or children components.\nUsage\nDisplay a pending state during form submission\nTo display a pending state while a form is submitting, you can call the\nuseFormStatus\nHook in a component rendered in a\n<form>\nand read the\npending\nproperty returned.\nHere, we use the\npending\nproperty to indicate the form is submitting.\nApp.js\nApp.js\nReset\nFork\nimport\n{\nuseFormStatus\n}\nfrom\n\"react-dom\"\n;\nimport\n{\nsubmitForm\n}\nfrom\n\"./actions.js\"\n;\nfunction\nSubmit\n(\n)\n{\nconst\n{\npending\n}\n=\nuseFormStatus\n(\n)\n;\nreturn\n(\n<\nbutton\ntype\n=\n\"submit\"\ndisabled\n=\n{\npending\n}\n>\n{\npending\n?\n\"Submitting...\"\n:\n\"Submit\"\n}\n</\nbutton\n>\n)\n;\n}\nfunction\nForm\n(\n{\naction\n}\n)\n{\nreturn\n(\n<\nform\naction\n=\n{\naction\n}\n>\n<\nSubmit\n/>\n</\nform\n>\n)\n;\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nreturn\n<\nForm\naction\n=\n{\nsubmitForm\n}\n/>\n;\n}\nShow more\nPitfall\nuseFormStatus\nwill not return status information for a\n<form>\nrendered in the same component.\nThe\nuseFormStatus\nHook only returns status information for a parent\n<form>\nand not for any\n<form>\nrendered in the same component calling the Hook, or child components.\nfunction\nForm\n(\n)\n{\n// üö© `pending` will never be true\n// useFormStatus does not track the form rendered in this component\nconst\n{\npending\n}\n=\nuseFormStatus\n(\n)\n;\nreturn\n<\nform\naction\n=\n{\nsubmit\n}\n>\n</\nform\n>\n;\n}\nInstead call\nuseFormStatus\nfrom inside a component that is located inside\n<form>\n.\nfunction\nSubmit\n(\n)\n{\n// ‚úÖ `pending` will be derived from the form that wraps the Submit component\nconst\n{\npending\n}\n=\nuseFormStatus\n(\n)\n;\nreturn\n<\nbutton\ndisabled\n=\n{\npending\n}\n>\n...\n</\nbutton\n>\n;\n}\nfunction\nForm\n(\n)\n{\n// This is the <form> `useFormStatus` tracks\nreturn\n(\n<\nform\naction\n=\n{\nsubmit\n}\n>\n<\nSubmit\n/>\n</\nform\n>\n)\n;\n}\nRead the form data being submitted\nYou can use the\ndata\nproperty of the status information returned from\nuseFormStatus\nto display what data is being submitted by the user.\nHere, we have a form where users can request a username. We can use\nuseFormStatus\nto display a temporary status message confirming what username they have requested.\nUsernameForm.js\nApp.js\nUsernameForm.js\nReset\nFork\nimport\n{\nuseState\n,\nuseMemo\n,\nuseRef\n}\nfrom\n'react'\n;\nimport\n{\nuseFormStatus\n}\nfrom\n'react-dom'\n;\nexport\ndefault\nfunction\nUsernameForm\n(\n)\n{\nconst\n{\npending\n,\ndata\n}\n=\nuseFormStatus\n(\n)\n;\nreturn\n(\n<\ndiv\n>\n<\nh3\n>\nRequest a Username:\n</\nh3\n>\n<\ninput\ntype\n=\n\"text\"\nname\n=\n\"username\"\ndisabled\n=\n{\npending\n}\n/>\n<\nbutton\ntype\n=\n\"submit\"\ndisabled\n=\n{\npending\n}\n>\nSubmit\n</\nbutton\n>\n<\nbr\n/>\n<\np\n>\n{\ndata\n?\n`Requesting\n${\ndata\n?.\nget\n(\n\"username\"\n)\n}\n...`\n:\n''\n}\n</\np\n>\n</\ndiv\n>\n)\n;\n}\nShow more\nTroubleshooting\nstatus.pending\nis never\ntrue\nuseFormStatus\nwill only return status information for a parent\n<form>\n.\nIf the component that calls\nuseFormStatus\nis not nested in a\n<form>\n,\nstatus.pending\nwill always return\nfalse\n. Verify\nuseFormStatus\nis called in a component that is a child of a\n<form>\nelement.\nuseFormStatus\nwill not track the status of a\n<form>\nrendered in the same component. See\nPitfall\nfor more details.\nPrevious\nHooks\nNext\nComponents",
    "url": "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "source": "react",
    "doc_type": "api_reference",
    "scraped_at": 12307.7203256
  },
  {
    "title": "Describing the UI",
    "content": "Learn React\nDescribing the UI\nReact is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestable\ncomponents.\nFrom web sites to phone apps, everything on the screen can be broken down into components. In this chapter, you‚Äôll learn to create, customize, and conditionally display React components.\nIn this chapter\nHow to write your first React component\nWhen and how to create multi-component files\nHow to add markup to JavaScript with JSX\nHow to use curly braces with JSX to access JavaScript functionality from your components\nHow to configure components with props\nHow to conditionally render components\nHow to render multiple components at a time\nHow to avoid confusing bugs by keeping components pure\nWhy understanding your UI as trees is useful\nYour first component\nReact applications are built from isolated pieces of UI called\ncomponents\n. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is a\nGallery\ncomponent rendering three\nProfile\ncomponents:\nApp.js\nApp.js\nReset\nFork\nfunction\nProfile\n(\n)\n{\nreturn\n(\n<\nimg\nsrc\n=\n\"https://i.imgur.com/MK3eW3As.jpg\"\nalt\n=\n\"Katherine Johnson\"\n/>\n)\n;\n}\nexport\ndefault\nfunction\nGallery\n(\n)\n{\nreturn\n(\n<\nsection\n>\n<\nh1\n>\nAmazing scientists\n</\nh1\n>\n<\nProfile\n/>\n<\nProfile\n/>\n<\nProfile\n/>\n</\nsection\n>\n)\n;\n}\nShow more\nReady to learn this topic?\nRead\nYour First Component\nto learn how to declare and use React components.\nRead More\nImporting and exporting components\nYou can declare many components in one file, but large files can get difficult to navigate. To solve this, you can\nexport\na component into its own file, and then\nimport\nthat component from another file:\nGallery.js\nProfile.js\nGallery.js\nReset\nFork\nimport\nProfile\nfrom\n'./Profile.js'\n;\nexport\ndefault\nfunction\nGallery\n(\n)\n{\nreturn\n(\n<\nsection\n>\n<\nh1\n>\nAmazing scientists\n</\nh1\n>\n<\nProfile\n/>\n<\nProfile\n/>\n<\nProfile\n/>\n</\nsection\n>\n)\n;\n}\nReady to learn this topic?\nRead\nImporting and Exporting Components\nto learn how to split components into their own files.\nRead More\nWriting markup with JSX\nEach React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information.\nIf we paste existing HTML markup into a React component, it won‚Äôt always work:\nApp.js\nApp.js\nReset\nFork\nexport\ndefault\nfunction\nTodoList\n(\n)\n{\nreturn\n(\n// This doesn't quite work!\n<\nh1\n>\nHedy Lamarr's Todos\n</\nh1\n>\n<\nimg\nsrc\n=\n\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt\n=\n\"Hedy Lamarr\"\nclass\n=\n\"photo\"\n>\n<\nul\n>\n<\nli\n>\nInvent new traffic lights\n<\nli\n>\nRehearse a movie scene\n<\nli\n>\nImprove spectrum technology\n</\nul\n>\nShow more\nIf you have existing HTML like this, you can fix it using a\nconverter\n:\nApp.js\nApp.js\nReset\nFork\nexport\ndefault\nfunction\nTodoList\n(\n)\n{\nreturn\n(\n<\n>\n<\nh1\n>\nHedy Lamarr's Todos\n</\nh1\n>\n<\nimg\nsrc\n=\n\"https://i.imgur.com/yXOvdOSs.jpg\"\nalt\n=\n\"Hedy Lamarr\"\nclassName\n=\n\"photo\"\n/>\n<\nul\n>\n<\nli\n>\nInvent new traffic lights\n</\nli\n>\n<\nli\n>\nRehearse a movie scene\n</\nli\n>\n<\nli\n>\nImprove spectrum technology\n</\nli\n>\n</\nul\n>\n</\n>\n)\n;\n}\nShow more\nReady to learn this topic?\nRead\nWriting Markup with JSX\nto learn how to write valid JSX.\nRead More\nJavaScript in JSX with curly braces\nJSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to ‚Äúopen a window‚Äù to JavaScript:\nApp.js\nApp.js\nReset\nFork\nconst\nperson\n=\n{\nname\n:\n'Gregorio Y. Zara'\n,\ntheme\n:\n{\nbackgroundColor\n:\n'black'\n,\ncolor\n:\n'pink'\n}\n}\n;\nexport\ndefault\nfunction\nTodoList\n(\n)\n{\nreturn\n(\n<\ndiv\nstyle\n=\n{\nperson\n.\ntheme\n}\n>\n<\nh1\n>\n{\nperson\n.\nname\n}\n's Todos\n</\nh1\n>\n<\nimg\nclassName\n=\n\"avatar\"\nsrc\n=\n\"https://i.imgur.com/7vQD0fPs.jpg\"\nalt\n=\n\"Gregorio Y. Zara\"\n/>\n<\nul\n>\n<\nli\n>\nImprove the videophone\n</\nli\n>\n<\nli\n>\nPrepare aeronautics lectures\n</\nli\n>\n<\nli\n>\nWork on the alcohol-fuelled engine\n</\nli\n>\n</\nul\n>\n</\ndiv\n>\n)\n;\n}\nShow more\nReady to learn this topic?\nRead\nJavaScript in JSX with Curly Braces\nto learn how to access JavaScript data from JSX.\nRead More\nPassing props to a component\nReact components use\nprops\nto communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX!\nApp.js\nutils.js\nApp.js\nReset\nFork\nimport\n{\ngetImageUrl\n}\nfrom\n'./utils.js'\nexport\ndefault\nfunction\nProfile\n(\n)\n{\nreturn\n(\n<\nCard\n>\n<\nAvatar\nsize\n=\n{\n100\n}\nperson\n=\n{\n{\nname\n:\n'Katsuko Saruhashi'\n,\nimageId\n:\n'YfeOqp2'\n}\n}\n/>\n</\nCard\n>\n)\n;\n}\nfunction\nAvatar\n(\n{\nperson\n,\nsize\n}\n)\n{\nreturn\n(\n<\nimg\nclassName\n=\n\"avatar\"\nsrc\n=\n{\ngetImageUrl\n(\nperson\n)\n}\nalt\n=\n{\nperson\n.\nname\n}\nwidth\n=\n{\nsize\n}\nheight\n=\n{\nsize\n}\n/>\n)\n;\n}\nfunction\nCard\n(\n{\nchildren\n}\n)\n{\nreturn\n(\n<\ndiv\nclassName\n=\n\"card\"\n>\n{\nchildren\n}\n</\ndiv\n>\n)\n;\n}\nShow more\nReady to learn this topic?\nRead\nPassing Props to a Component\nto learn how to pass and read props.\nRead More\nConditional rendering\nYour components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like\nif\nstatements,\n&&\n, and\n? :\noperators.\nIn this example, the JavaScript\n&&\noperator is used to conditionally render a checkmark:\nApp.js\nApp.js\nReset\nFork\nfunction\nItem\n(\n{\nname\n,\nisPacked\n}\n)\n{\nreturn\n(\n<\nli\nclassName\n=\n\"item\"\n>\n{\nname\n}\n{\nisPacked\n&&\n'‚úÖ'\n}\n</\nli\n>\n)\n;\n}\nexport\ndefault\nfunction\nPackingList\n(\n)\n{\nreturn\n(\n<\nsection\n>\n<\nh1\n>\nSally Ride's Packing List\n</\nh1\n>\n<\nul\n>\n<\nItem\nisPacked\n=\n{\ntrue\n}\nname\n=\n\"Space suit\"\n/>\n<\nItem\nisPacked\n=\n{\ntrue\n}\nname\n=\n\"Helmet with a golden leaf\"\n/>\n<\nItem\nisPacked\n=\n{\nfalse\n}\nname\n=\n\"Photo of Tam\"\n/>\n</\nul\n>\n</\nsection\n>\n)\n;\n}\nShow more\nReady to learn this topic?\nRead\nConditional Rendering\nto learn the different ways to render content conditionally.\nRead More\nRendering lists\nYou will often want to display multiple similar components from a collection of data. You can use JavaScript‚Äôs\nfilter()\nand\nmap()\nwith React to filter and transform your array of data into an array of components.\nFor each array item, you will need to specify a\nkey\n. Usually, you will want to use an ID from the database as a\nkey\n. Keys let React keep track of each item‚Äôs place in the list even if the list changes.\nApp.js\ndata.js\nutils.js\nApp.js\nReset\nFork\nimport\n{\npeople\n}\nfrom\n'./data.js'\n;\nimport\n{\ngetImageUrl\n}\nfrom\n'./utils.js'\n;\nexport\ndefault\nfunction\nList\n(\n)\n{\nconst\nlistItems\n=\npeople\n.\nmap\n(\nperson\n=>\n<\nli\nkey\n=\n{\nperson\n.\nid\n}\n>\n<\nimg\nsrc\n=\n{\ngetImageUrl\n(\nperson\n)\n}\nalt\n=\n{\nperson\n.\nname\n}\n/>\n<\np\n>\n<\nb\n>\n{\nperson\n.\nname\n}\n:\n</\nb\n>\n{\n' '\n+\nperson\n.\nprofession\n+\n' '\n}\nknown for\n{\nperson\n.\naccomplishment\n}\n</\np\n>\n</\nli\n>\n)\n;\nreturn\n(\n<\narticle\n>\n<\nh1\n>\nScientists\n</\nh1\n>\n<\nul\n>\n{\nlistItems\n}\n</\nul\n>\n</\narticle\n>\n)\n;\n}\nShow more\nReady to learn this topic?\nRead\nRendering Lists\nto learn how to render a list of components, and how to choose a key.\nRead More\nKeeping components pure\nSome JavaScript functions are\npure.\nA pure function:\nMinds its own business.\nIt does not change any objects or variables that existed before it was called.\nSame inputs, same output.\nGiven the same inputs, a pure function should always return the same result.\nBy strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component:\nApp.js\nApp.js\nReset\nFork\nlet\nguest\n=\n0\n;\nfunction\nCup\n(\n)\n{\n// Bad: changing a preexisting variable!\nguest\n=\nguest\n+\n1\n;\nreturn\n<\nh2\n>\nTea cup for guest #\n{\nguest\n}\n</\nh2\n>\n;\n}\nexport\ndefault\nfunction\nTeaSet\n(\n)\n{\nreturn\n(\n<\n>\n<\nCup\n/>\n<\nCup\n/>\n<\nCup\n/>\n</\n>\n)\n;\n}\nShow more\nYou can make this component pure by passing a prop instead of modifying a preexisting variable:\nApp.js\nApp.js\nReset\nFork\nfunction\nCup\n(\n{\nguest\n}\n)\n{\nreturn\n<\nh2\n>\nTea cup for guest #\n{\nguest\n}\n</\nh2\n>\n;\n}\nexport\ndefault\nfunction\nTeaSet\n(\n)\n{\nreturn\n(\n<\n>\n<\nCup\nguest\n=\n{\n1\n}\n/>\n<\nCup\nguest\n=\n{\n2\n}\n/>\n<\nCup\nguest\n=\n{\n3\n}\n/>\n</\n>\n)\n;\n}\nReady to learn this topic?\nRead\nKeeping Components Pure\nto learn how to write components as pure, predictable functions.\nRead More\nYour UI as a tree\nReact uses trees to model the relationships between components and modules.\nA React render tree is a representation of the parent and child relationship between components.\nAn example React render tree.\nComponents near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance.\nModelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree.\nAn example module dependency tree.\nA dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues.\nReady to learn this topic?\nRead\nYour UI as a Tree\nto learn how to create a render and module dependency trees for a React app and how they‚Äôre useful mental models for improving user experience and performance.\nRead More\nWhat‚Äôs next?\nHead over to\nYour First Component\nto start reading this chapter page by page!\nOr, if you‚Äôre already familiar with these topics, why not read about\nAdding Interactivity\n?\nNext\nYour First Component",
    "url": "https://react.dev/learn/describing-the-ui",
    "source": "react",
    "doc_type": "tutorial",
    "scraped_at": 12308.2730022
  },
  {
    "title": "Acknowledgements",
    "content": "Community\nAcknowledgements\nReact was originally created by\nJordan Walke.\nToday, React has a\ndedicated full-time team working on it\n, as well as over a thousand\nopen source contributors.\nPast contributors\nWe‚Äôd like to recognize a few people who have made significant contributions to React and its documentation in the past and have helped maintain them over the years:\nAlmero Steyn\nAndreas Svensson\nAlex Krolick\nAlexey Pyltsyn\nAndrey Lunyov\nBrandon Dail\nBrian Vaughn\nCaleb Meredith\nChang Yan\nCheng Lou\nChristoph Nakazawa\nChristopher Chedeau\nClement Hoang\nDave McCabe\nDominic Gannaway\nFlarnie Marchan\nJason Quense\nJesse Beach\nJessica Franco\nJim Sproch\nJosh Duck\nJoe Critchley\nJeff Morrison\nLuna Ruan\nLuna Wei\nNoah Lemen\nKathryn Middleton\nKeyan Zhang\nMarco Salazar\nMengdi Chen\nNat Alison\nNathan Hunzaker\nNicolas Gallagher\nPaul O‚ÄôShannessy\nPete Hunt\nPhilipp Spiess\nRachel Nabors\nRobert Zhang\nSamuel Susla\nSander Spies\nSasha Aickin\nSathya Gunasekaran\nSophia Shoemaker\nSunil Pai\nTianyu Yao\nTim Yung\nXuan Huang\nThis list is not exhaustive.\nWe‚Äôd like to give special thanks to\nTom Occhino\nand\nAdam Wolff\nfor their guidance and support over the years. We are also thankful to all the volunteers who\ntranslated React into other languages.\nAdditional Thanks\nAdditionally, we‚Äôre grateful to:\nJeff Barczewski\nfor allowing us to use the\nreact\npackage name on npm\nChristopher Aue\nfor letting us use the reactjs.com domain name and the\n@reactjs\nusername on Twitter\nProjectMoon\nfor letting us use the\nflux\npackage name on npm\nShane Anderson for allowing us to use the\nreact\norg on GitHub\nPrevious\nTranslations\nNext\nVersioning Policy",
    "url": "https://react.dev/community/acknowledgements",
    "source": "react",
    "doc_type": "conceptual",
    "scraped_at": 12309.0799718
  },
  {
    "title": "Next.js Docs",
    "content": "Menu\nUsing App Router\nFeatures available in /app\nUsing Latest Version\n15.4.4\nNext.js Docs\nWelcome to the Next.js documentation!\nWhat is Next.js?\nNext.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js for additional features and optimizations.\nIt also automatically configures lower-level tools like bundlers and compilers. You can instead focus on building your product and shipping quickly.\nWhether you're an individual developer or part of a larger team, Next.js can help you build interactive, dynamic, and fast React applications.\nHow to use the docs\nThe docs are organized into 3 sections:\nGetting Started\n: Step-by-step tutorials to help you create a new application and learn the core Next.js features.\nGuides\n: Tutorials on specific use cases, choose what's relevant to you.\nAPI Reference\n: Detailed technical reference for every feature.\nUse the sidebar to navigate through the sections, or search (\nCtrl+K\nor\nCmd+K\n) to quickly find a page.\nApp Router and Pages Router\nNext.js has two different routers:\nApp Router\n: The newer router that supports new React features like Server Components.\nPages Router\n: The original router, still supported and being improved.\nAt the top of the sidebar, you'll notice a dropdown menu that allows you to switch between the\nApp Router\nand the\nPages Router\ndocs.\nPre-requisite knowledge\nOur documentation assumes some familiarity with web development. Before getting started, it'll help if you're comfortable with:\nHTML\nCSS\nJavaScript\nReact\nIf you're new to React or need a refresher, we recommend starting with our\nReact Foundations course\n, and the\nNext.js Foundations course\nthat has you building an application as you learn.\nAccessibility\nFor the best experience when using a screen reader, we recommend using Firefox and NVDA, or Safari and VoiceOver.\nJoin our Community\nIf you have questions about anything related to Next.js, you're always welcome to ask our community on\nGitHub Discussions\n,\nDiscord\n,\nX (Twitter)\n, and\nReddit\n.\nNext Steps\nCreate your first application and learn the core Next.js features.\nGetting Started\nLearn how to create full-stack web applications with the Next.js App Router.\nWas this helpful?\nsupported.\nSend",
    "url": "https://nextjs.org/docs",
    "source": "nextjs",
    "doc_type": "conceptual",
    "scraped_at": 12309.8665834
  },
  {
    "title": "urlImports",
    "content": "Menu\nUsing App Router\nFeatures available in /app\nUsing Latest Version\n15.4.4\nConfiguration\nnext.config.js\nurlImports\nCopy page\nurlImports\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on\nGitHub\n.\nURL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local disk).\nWarning\n: Only use domains that you trust to download and execute on your machine. Please exercise discretion, and caution until the feature is flagged as stable.\nTo opt-in, add the allowed URL prefixes inside\nnext.config.js\n:\nnext.config.js\nmodule\n.\nexports\n=\n{\nexperimental\n:\n{\nurlImports\n:\n[\n'https://example.com/assets/'\n,\n'https://cdn.skypack.dev'\n]\n,\n}\n,\n}\nThen, you can import modules directly from URLs:\nimport\n{ a\n,\nb\n,\nc }\nfrom\n'https://example.com/assets/some/module.js'\nURL Imports can be used everywhere normal package imports can be used.\nSecurity Model\nThis feature is being designed with\nsecurity as the top priority\n. To start, we added an experimental flag forcing you to explicitly allow the domains you accept URL imports from. We're working to take this further by limiting URL imports to execute in the browser sandbox using the\nEdge Runtime\n.\nLockfile\nWhen using URL imports, Next.js will create a\nnext.lock\ndirectory containing a lockfile and fetched assets.\nThis directory\nmust be committed to Git\n, not ignored by\n.gitignore\n.\nWhen running\nnext dev\n, Next.js will download and add all newly discovered URL Imports to your lockfile.\nWhen running\nnext build\n, Next.js will use only the lockfile to build the application for production.\nTypically, no network requests are needed and any outdated lockfile will cause the build to fail.\nOne exception is resources that respond with\nCache-Control: no-cache\n.\nThese resources will have a\nno-cache\nentry in the lockfile and will always be fetched from the network on each build.\nExamples\nSkypack\nimport\nconfetti\nfrom\n'https://cdn.skypack.dev/canvas-confetti'\nimport\n{ useEffect }\nfrom\n'react'\nexport\ndefault\n()\n=>\n{\nuseEffect\n(()\n=>\n{\nconfetti\n()\n})\nreturn\n<\np\n>Hello</\np\n>\n}\nStatic Image Imports\nimport\nImage\nfrom\n'next/image'\nimport\nlogo\nfrom\n'https://example.com/assets/logo.png'\nexport\ndefault\n()\n=>\n(\n<\ndiv\n>\n<\nImage\nsrc\n=\n{logo}\nplaceholder\n=\n\"blur\"\n/>\n</\ndiv\n>\n)\nURLs in CSS\n.className\n{\nbackground\n:\nurl\n(\n'https://example.com/assets/hero.jpg'\n)\n;\n}\nAsset Imports\nconst\nlogo\n=\nnew\nURL\n(\n'https://example.com/assets/file.txt'\n,\nimport\n.\nmeta\n.url)\nconsole\n.log\n(\nlogo\n.pathname)\n// prints \"/_next/static/media/file.a9727b5d.txt\"\nWas this helpful?\nsupported.\nSend",
    "url": "https://nextjs.org/docs/app/api-reference/config/next-config-js/urlImports",
    "source": "nextjs",
    "doc_type": "api_reference",
    "scraped_at": 12310.5022232
  },
  {
    "title": "How to upgrade to version 13",
    "content": "Menu\nUsing App Router\nFeatures available in /app\nUsing Latest Version\n15.4.4\nGuides\nUpgrading\nVersion 13\nCopy page\nYou are currently viewing the documentation for Pages Router.\nHow to upgrade to version 13\nUpgrading from 12 to 13\nTo update to Next.js version 13, run the following command using your preferred package manager:\nTerminal\nnpm\ni\nnext@13\nreact@latest\nreact-dom@latest\neslint-config-next@13\nTerminal\nyarn\nadd\nnext@13\nreact@latest\nreact-dom@latest\neslint-config-next@13\nTerminal\npnpm\ni\nnext@13\nreact@latest\nreact-dom@latest\neslint-config-next@13\nTerminal\nbun\nadd\nnext@13\nreact@latest\nreact-dom@latest\neslint-config-next@13\nGood to know:\nIf you are using TypeScript, ensure you also upgrade\n@types/react\nand\n@types/react-dom\nto their latest versions.\nv13 Summary\nThe\nSupported Browsers\nhave been changed to drop Internet Explorer and target modern browsers.\nThe minimum Node.js version has been bumped from 12.22.0 to 16.14.0, since 12.x and 14.x have reached end-of-life.\nThe minimum React version has been bumped from 17.0.2 to 18.2.0.\nThe\nswcMinify\nconfiguration property was changed from\nfalse\nto\ntrue\n. See\nNext.js Compiler\nfor more info.\nThe\nnext/image\nimport was renamed to\nnext/legacy/image\n. The\nnext/future/image\nimport was renamed to\nnext/image\n. A\ncodemod is available\nto safely and automatically rename your imports.\nThe\nnext/link\nchild can no longer be\n<a>\n. Add the\nlegacyBehavior\nprop to use the legacy behavior or remove the\n<a>\nto upgrade. A\ncodemod is available\nto automatically upgrade your code.\nThe\ntarget\nconfiguration property has been removed and superseded by\nOutput File Tracing\n.\nMigrating shared features\nNext.js 13 introduces a new\napp\ndirectory\nwith new features and conventions. However, upgrading to Next.js 13 does\nnot\nrequire using the new\napp\nRouter.\nYou can continue using\npages\nwith new features that work in both directories, such as the updated\nImage component\n,\nLink component\n,\nScript component\n, and\nFont optimization\n.\n<Image/>\nComponent\nNext.js 12 introduced many improvements to the Image Component with a temporary import:\nnext/future/image\n. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.\nStarting in Next.js 13, this new behavior is now the default for\nnext/image\n.\nThere are two codemods to help you migrate to the new Image Component:\nnext-image-to-legacy-image\n: This codemod will safely and automatically rename\nnext/image\nimports to\nnext/legacy/image\nto maintain the same behavior as Next.js 12. We recommend running this codemod to quickly update to Next.js 13 automatically.\nnext-image-experimental\n: After running the previous codemod, you can optionally run this experimental codemod to upgrade\nnext/legacy/image\nto the new\nnext/image\n, which will remove unused props and add inline styles. Please note this codemod is experimental and only covers static usage (such as\n<Image src={img} layout=\"responsive\" />\n) but not dynamic usage (such as\n<Image {...props} />\n).\nAlternatively, you can manually update by following the\nmigration guide\nand also see the\nlegacy comparison\n.\n<Link>\nComponent\nThe\n<Link>\nComponent\nno longer requires manually adding an\n<a>\ntag as a child. This behavior was added as an experimental option in\nversion 12.2\nand is now the default. In Next.js 13,\n<Link>\nalways renders\n<a>\nand allows you to forward props to the underlying tag.\nFor example:\nimport\nLink\nfrom\n'next/link'\n// Next.js 12: `<a>` has to be nested otherwise it's excluded\n<\nLink\nhref\n=\n\"/about\"\n>\n<\na\n>About</\na\n>\n</\nLink\n>\n// Next.js 13: `<Link>` always renders `<a>` under the hood\n<\nLink\nhref\n=\n\"/about\"\n>\nAbout\n</\nLink\n>\nTo upgrade your links to Next.js 13, you can use the\nnew-link\ncodemod\n.\n<Script>\nComponent\nThe behavior of\nnext/script\nhas been updated to support both\npages\nand\napp\n. If incrementally adopting\napp\n, read the\nupgrade guide\n.\nFont Optimization\nPreviously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new\nnext/font\nmodule which gives you the ability to customize your font loading experience while still ensuring great performance and privacy.\nSee\nOptimizing Fonts\nto learn how to use\nnext/font\n.\nWas this helpful?\nsupported.\nSend",
    "url": "https://nextjs.org/docs/pages/guides/upgrading/version-13",
    "source": "nextjs",
    "doc_type": "tutorial",
    "scraped_at": 12311.2248375
  },
  {
    "title": "optimizePackageImports",
    "content": "Menu\nUsing App Router\nFeatures available in /app\nUsing Latest Version\n15.4.4\nConfiguration\nnext.config.js Options\noptimizePackageImports\nCopy page\nYou are currently viewing the documentation for Pages Router.\noptimizePackageImports\nSome packages can export hundreds or thousands of modules, which can cause performance issues in development and production.\nAdding a package to\nexperimental.optimizePackageImports\nwill only load the modules you are actually using, while still giving you the convenience of writing import statements with many named exports.\nnext.config.js\nmodule\n.\nexports\n=\n{\nexperimental\n:\n{\noptimizePackageImports\n:\n[\n'package-name'\n]\n,\n}\n,\n}\nThe following libraries are optimized by default:\nlucide-react\ndate-fns\nlodash-es\nramda\nantd\nreact-bootstrap\nahooks\n@ant-design/icons\n@headlessui/react\n@headlessui-float/react\n@heroicons/react/20/solid\n@heroicons/react/24/solid\n@heroicons/react/24/outline\n@visx/visx\n@tremor/react\nrxjs\n@mui/material\n@mui/icons-material\nrecharts\nreact-use\n@material-ui/core\n@material-ui/icons\n@tabler/icons-react\nmui-core\nreact-icons/*\neffect\n@effect/*\nWas this helpful?\nsupported.\nSend",
    "url": "https://nextjs.org/docs/pages/api-reference/config/next-config-js/optimizePackageImports",
    "source": "nextjs",
    "doc_type": "api_reference",
    "scraped_at": 12311.8935405
  }
]




