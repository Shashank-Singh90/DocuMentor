Django 5.2 Complete Framework Documentation

Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design.

INSTALLATION AND SETUP

Installation:
pip install django==5.2

# Optional packages
pip install psycopg2-binary  # PostgreSQL adapter
pip install mysqlclient      # MySQL adapter
pip install redis           # Redis cache backend
pip install celery          # Async task queue
pip install django-extensions  # Useful extensions
pip install django-debug-toolbar  # Debug toolbar
pip install pillow          # Image processing

Starting a Project:
django-admin startproject myproject
cd myproject
python manage.py startapp myapp

PROJECT STRUCTURE

Basic Structure:
myproject/
├── manage.py
├── myproject/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   ├── wsgi.py
│   └── asgi.py
└── myapp/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── migrations/
    ├── models.py
    ├── tests.py
    └── views.py

SETTINGS CONFIGURATION

Basic Settings (settings.py):
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = 'your-secret-key-here'
DEBUG = True
ALLOWED_HOSTS = ['localhost', '127.0.0.1']

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'myproject.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

Database Configuration:
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# PostgreSQL
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydb',
        'USER': 'myuser',
        'PASSWORD': 'mypassword',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}

Static Files:
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_DIRS = [BASE_DIR / 'static']

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

MODELS

Basic Model Definition:
from django.db import models
from django.contrib.auth.models import User

class Category(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name_plural = "categories"
        ordering = ['name']

    def __str__(self):
        return self.name

class Post(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='posts')
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, blank=True)
    content = models.TextField()
    excerpt = models.CharField(max_length=300, blank=True)
    featured_image = models.ImageField(upload_to='posts/', blank=True, null=True)
    published = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    tags = models.ManyToManyField('Tag', blank=True)

    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['published', 'created_at']),
        ]

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        from django.urls import reverse
        return reverse('post_detail', kwargs={'slug': self.slug})

class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)

    def __str__(self):
        return self.name

Field Types:
# Text Fields
models.CharField(max_length=200)
models.TextField()
models.SlugField()
models.EmailField()
models.URLField()

# Number Fields
models.IntegerField()
models.BigIntegerField()
models.FloatField()
models.DecimalField(max_digits=10, decimal_places=2)

# Date/Time Fields
models.DateField()
models.TimeField()
models.DateTimeField()
models.DurationField()

# Boolean Fields
models.BooleanField()
models.NullBooleanField()  # Deprecated in Django 4.0+

# File Fields
models.FileField(upload_to='files/')
models.ImageField(upload_to='images/')

# Relationship Fields
models.ForeignKey(OtherModel, on_delete=models.CASCADE)
models.OneToOneField(OtherModel, on_delete=models.CASCADE)
models.ManyToManyField(OtherModel)

Model Methods:
class Post(models.Model):
    # ... fields ...

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse('post_detail', kwargs={'slug': self.slug})

    @property
    def word_count(self):
        return len(self.content.split())

    def get_related_posts(self):
        return Post.objects.filter(
            category=self.category,
            published=True
        ).exclude(id=self.id)[:5]

VIEWS

Function-Based Views:
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, JsonResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import Post, Category
from .forms import PostForm

def post_list(request):
    posts = Post.objects.filter(published=True)
    categories = Category.objects.all()

    category_filter = request.GET.get('category')
    if category_filter:
        posts = posts.filter(category__name=category_filter)

    context = {
        'posts': posts,
        'categories': categories,
    }
    return render(request, 'blog/post_list.html', context)

def post_detail(request, slug):
    post = get_object_or_404(Post, slug=slug, published=True)
    return render(request, 'blog/post_detail.html', {'post': post})

@login_required
def post_create(request):
    if request.method == 'POST':
        form = PostForm(request.POST, request.FILES)
        if form.is_valid():
            post = form.save(commit=False)
            post.author = request.user
            post.save()
            form.save_m2m()
            messages.success(request, 'Post created successfully!')
            return redirect('post_detail', slug=post.slug)
    else:
        form = PostForm()

    return render(request, 'blog/post_form.html', {'form': form})

Class-Based Views:
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse_lazy

class PostListView(ListView):
    model = Post
    template_name = 'blog/post_list.html'
    context_object_name = 'posts'
    paginate_by = 10

    def get_queryset(self):
        return Post.objects.filter(published=True)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['categories'] = Category.objects.all()
        return context

class PostDetailView(DetailView):
    model = Post
    template_name = 'blog/post_detail.html'
    context_object_name = 'post'

    def get_queryset(self):
        return Post.objects.filter(published=True)

class PostCreateView(LoginRequiredMixin, CreateView):
    model = Post
    form_class = PostForm
    template_name = 'blog/post_form.html'

    def form_valid(self, form):
        form.instance.author = self.request.user
        return super().form_valid(form)

class PostUpdateView(LoginRequiredMixin, UpdateView):
    model = Post
    form_class = PostForm
    template_name = 'blog/post_form.html'

    def get_queryset(self):
        return Post.objects.filter(author=self.request.user)

class PostDeleteView(LoginRequiredMixin, DeleteView):
    model = Post
    template_name = 'blog/post_confirm_delete.html'
    success_url = reverse_lazy('post_list')

    def get_queryset(self):
        return Post.objects.filter(author=self.request.user)

URLS

URL Configuration:
# myproject/urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
    path('accounts/', include('django.contrib.auth.urls')),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

# blog/urls.py
from django.urls import path
from . import views

app_name = 'blog'

urlpatterns = [
    path('', views.PostListView.as_view(), name='post_list'),
    path('post/<slug:slug>/', views.PostDetailView.as_view(), name='post_detail'),
    path('create/', views.PostCreateView.as_view(), name='post_create'),
    path('post/<slug:slug>/edit/', views.PostUpdateView.as_view(), name='post_edit'),
    path('post/<slug:slug>/delete/', views.PostDeleteView.as_view(), name='post_delete'),
    path('category/<str:category>/', views.post_list, name='posts_by_category'),
]

TEMPLATES

Template Syntax:
<!-- base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}My Blog{% endblock %}</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/style.css' %}">
</head>
<body>
    <nav>
        <a href="{% url 'blog:post_list' %}">Home</a>
        {% if user.is_authenticated %}
            <a href="{% url 'blog:post_create' %}">Create Post</a>
            <a href="{% url 'admin:logout' %}">Logout</a>
        {% else %}
            <a href="{% url 'admin:login' %}">Login</a>
        {% endif %}
    </nav>

    <main>
        {% if messages %}
            {% for message in messages %}
                <div class="alert alert-{{ message.tags }}">
                    {{ message }}
                </div>
            {% endfor %}
        {% endif %}

        {% block content %}
        {% endblock %}
    </main>
</body>
</html>

<!-- post_list.html -->
{% extends 'base.html' %}

{% block title %}Posts - {{ block.super }}{% endblock %}

{% block content %}
    <h1>Latest Posts</h1>

    <div class="filters">
        <h3>Categories</h3>
        <ul>
            <li><a href="{% url 'blog:post_list' %}">All</a></li>
            {% for category in categories %}
                <li><a href="{% url 'blog:posts_by_category' category.name %}">{{ category.name }}</a></li>
            {% endfor %}
        </ul>
    </div>

    <div class="posts">
        {% for post in posts %}
            <article class="post-preview">
                <h2><a href="{{ post.get_absolute_url }}">{{ post.title }}</a></h2>
                <p class="meta">
                    By {{ post.author.get_full_name|default:post.author.username }}
                    on {{ post.created_at|date:"F d, Y" }}
                    {% if post.category %}
                        in <a href="{% url 'blog:posts_by_category' post.category.name %}">{{ post.category.name }}</a>
                    {% endif %}
                </p>
                {% if post.excerpt %}
                    <p>{{ post.excerpt }}</p>
                {% else %}
                    <p>{{ post.content|truncatewords:50 }}</p>
                {% endif %}
                <a href="{{ post.get_absolute_url }}">Read more</a>
            </article>
        {% empty %}
            <p>No posts found.</p>
        {% endfor %}
    </div>

    {% if is_paginated %}
        <div class="pagination">
            <span class="page-links">
                {% if page_obj.has_previous %}
                    <a href="?page={{ page_obj.previous_page_number }}">previous</a>
                {% endif %}

                <span class="current">
                    Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}
                </span>

                {% if page_obj.has_next %}
                    <a href="?page={{ page_obj.next_page_number }}">next</a>
                {% endif %}
            </span>
        </div>
    {% endif %}
{% endblock %}

Template Tags and Filters:
<!-- Built-in tags -->
{% if condition %}...{% endif %}
{% for item in items %}...{% empty %}...{% endfor %}
{% with new_var=old_var %}...{% endwith %}
{% url 'view_name' arg1 arg2 %}
{% static 'path/to/file' %}
{% csrf_token %}

<!-- Built-in filters -->
{{ value|default:"default text" }}
{{ text|length }}
{{ text|truncatewords:50 }}
{{ date|date:"Y-m-d" }}
{{ number|floatformat:2 }}
{{ text|safe }}
{{ text|escape }}
{{ list|join:", " }}

Custom Template Tags:
# blog/templatetags/blog_extras.py
from django import template
from django.utils.safestring import mark_safe
import markdown

register = template.Library()

@register.simple_tag
def total_posts():
    from blog.models import Post
    return Post.objects.filter(published=True).count()

@register.filter
def markdown_to_html(text):
    return mark_safe(markdown.markdown(text))

@register.inclusion_tag('blog/latest_posts.html')
def show_latest_posts(count=5):
    from blog.models import Post
    latest_posts = Post.objects.filter(published=True)[:count]
    return {'latest_posts': latest_posts}

FORMS

Form Definition:
from django import forms
from django.contrib.auth.models import User
from .models import Post, Category

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ['title', 'category', 'content', 'excerpt', 'featured_image', 'tags', 'published']
        widgets = {
            'content': forms.Textarea(attrs={'rows': 10}),
            'excerpt': forms.TextInput(attrs={'placeholder': 'Brief description...'}),
            'tags': forms.CheckboxSelectMultiple(),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['category'].queryset = Category.objects.all()
        self.fields['title'].widget.attrs.update({'class': 'form-control'})

    def clean_title(self):
        title = self.cleaned_data['title']
        if len(title) < 5:
            raise forms.ValidationError("Title must be at least 5 characters long.")
        return title

Regular Forms:
class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    subject = forms.CharField(max_length=200)
    message = forms.CharField(widget=forms.Textarea)

    def clean_email(self):
        email = self.cleaned_data['email']
        if not email.endswith('@example.com'):
            raise forms.ValidationError('Please use your company email.')
        return email

    def send_email(self):
        # Send email logic here
        pass

Form Handling in Views:
def contact_view(request):
    if request.method == 'POST':
        form = ContactForm(request.POST)
        if form.is_valid():
            form.send_email()
            messages.success(request, 'Message sent successfully!')
            return redirect('contact')
    else:
        form = ContactForm()

    return render(request, 'contact.html', {'form': form})

ADMIN

Admin Configuration:
from django.contrib import admin
from .models import Post, Category, Tag

@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ['name', 'description']
    search_fields = ['name']

@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    list_display = ['name']
    search_fields = ['name']

@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ['title', 'author', 'category', 'published', 'created_at']
    list_filter = ['published', 'created_at', 'category', 'author']
    search_fields = ['title', 'content']
    prepopulated_fields = {'slug': ('title',)}
    raw_id_fields = ['author']
    date_hierarchy = 'created_at'
    ordering = ['-created_at']

    fieldsets = (
        ('Basic Information', {
            'fields': ('title', 'slug', 'author', 'category')
        }),
        ('Content', {
            'fields': ('content', 'excerpt', 'featured_image')
        }),
        ('Metadata', {
            'fields': ('tags', 'published'),
            'classes': ('collapse',)
        }),
    )

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.user.is_superuser:
            return qs
        return qs.filter(author=request.user)

Custom Admin Actions:
@admin.action(description='Mark selected posts as published')
def make_published(modeladmin, request, queryset):
    queryset.update(published=True)

@admin.action(description='Mark selected posts as unpublished')
def make_unpublished(modeladmin, request, queryset):
    queryset.update(published=False)

class PostAdmin(admin.ModelAdmin):
    # ... other configuration ...
    actions = [make_published, make_unpublished]

AUTHENTICATION AND AUTHORIZATION

User Authentication:
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib.auth.models import User, Group, Permission

def login_view(request):
    if request.method == 'POST':
        username = request.POST['username']
        password = request.POST['password']
        user = authenticate(request, username=username, password=password)
        if user is not None:
            login(request, user)
            return redirect('home')
        else:
            messages.error(request, 'Invalid credentials')
    return render(request, 'registration/login.html')

@login_required
def profile_view(request):
    return render(request, 'profile.html')

@permission_required('blog.add_post')
def create_post_view(request):
    # Only users with add_post permission can access
    pass

Custom User Model:
from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    bio = models.TextField(blank=True)
    birth_date = models.DateField(null=True, blank=True)
    avatar = models.ImageField(upload_to='avatars/', blank=True)

# In settings.py
AUTH_USER_MODEL = 'myapp.CustomUser'

Groups and Permissions:
# Create groups and permissions
editors = Group.objects.create(name='Editors')
authors = Group.objects.create(name='Authors')

# Add permissions to groups
from django.contrib.contenttypes.models import ContentType
post_ct = ContentType.objects.get_for_model(Post)
edit_permission = Permission.objects.create(
    codename='can_edit_published',
    name='Can edit published posts',
    content_type=post_ct,
)

editors.permissions.add(edit_permission)

# Add user to group
user.groups.add(editors)

MIDDLEWARE

Custom Middleware:
class TimingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start_time = time.time()

        response = self.get_response(request)

        duration = time.time() - start_time
        response['X-Page-Duration-ms'] = int(duration * 1000)

        return response

    def process_exception(self, request, exception):
        # Handle exceptions
        return None

# Add to settings.py MIDDLEWARE list
MIDDLEWARE = [
    # ... other middleware ...
    'myapp.middleware.TimingMiddleware',
]

SIGNALS

Django Signals:
from django.db.models.signals import post_save, pre_delete
from django.dispatch import receiver
from django.contrib.auth.models import User

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        # Create user profile when user is created
        Profile.objects.create(user=instance)

@receiver(pre_delete, sender=Post)
def backup_post_before_delete(sender, instance, **kwargs):
    # Backup post before deletion
    with open(f'backup_post_{instance.id}.txt', 'w') as f:
        f.write(instance.content)

TESTING

Model Testing:
from django.test import TestCase
from django.contrib.auth.models import User
from .models import Post, Category

class PostModelTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        self.category = Category.objects.create(
            name='Test Category',
            description='Test description'
        )

    def test_post_creation(self):
        post = Post.objects.create(
            title='Test Post',
            slug='test-post',
            author=self.user,
            category=self.category,
            content='Test content',
            published=True
        )
        self.assertEqual(post.title, 'Test Post')
        self.assertEqual(str(post), 'Test Post')
        self.assertTrue(post.published)

    def test_post_get_absolute_url(self):
        post = Post.objects.create(
            title='Test Post',
            slug='test-post',
            author=self.user,
            content='Test content'
        )
        self.assertEqual(post.get_absolute_url(), '/post/test-post/')

View Testing:
from django.test import TestCase, Client
from django.urls import reverse
from django.contrib.auth.models import User

class PostViewTest(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123'
        )

    def test_post_list_view(self):
        response = self.client.get(reverse('blog:post_list'))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Latest Posts')

    def test_post_create_requires_login(self):
        response = self.client.get(reverse('blog:post_create'))
        self.assertRedirects(response, '/accounts/login/?next=/create/')

    def test_post_create_with_login(self):
        self.client.login(username='testuser', password='testpass123')
        response = self.client.get(reverse('blog:post_create'))
        self.assertEqual(response.status_code, 200)

Form Testing:
from django.test import TestCase
from .forms import PostForm

class PostFormTest(TestCase):
    def test_post_form_valid_data(self):
        form = PostForm(data={
            'title': 'Test Post Title',
            'content': 'Test content for the post',
            'published': True
        })
        self.assertTrue(form.is_valid())

    def test_post_form_no_data(self):
        form = PostForm(data={})
        self.assertFalse(form.is_valid())
        self.assertIn('title', form.errors)

DATABASE QUERIES

ORM Queries:
# Basic queries
posts = Post.objects.all()
published_posts = Post.objects.filter(published=True)
recent_posts = Post.objects.filter(created_at__gte=timezone.now() - timedelta(days=7))

# Get single object
post = Post.objects.get(slug='my-post')
post = Post.objects.filter(slug='my-post').first()

# Exclude
unpublished = Post.objects.exclude(published=True)

# Ordering
latest_posts = Post.objects.order_by('-created_at')
alphabetical = Post.objects.order_by('title')

# Slicing
first_five = Post.objects.all()[:5]
posts_6_to_10 = Post.objects.all()[5:10]

# Field lookups
Post.objects.filter(title__icontains='django')
Post.objects.filter(created_at__year=2024)
Post.objects.filter(author__username='john')

# Complex queries with Q objects
from django.db.models import Q
Post.objects.filter(Q(published=True) & (Q(category__name='Tech') | Q(tags__name='Python')))

# Aggregation
from django.db.models import Count, Avg
Category.objects.annotate(post_count=Count('post'))
Post.objects.aggregate(avg_word_count=Avg('word_count'))

# Prefetch related
posts_with_authors = Post.objects.select_related('author', 'category').prefetch_related('tags')

Raw SQL:
from django.db import connection

def custom_sql_query():
    with connection.cursor() as cursor:
        cursor.execute("SELECT * FROM blog_post WHERE published = %s", [True])
        return cursor.fetchall()

# Raw queries with model
posts = Post.objects.raw('SELECT * FROM blog_post WHERE published = %s', [True])

CACHING

Cache Configuration:
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
    }
}

# Alternative: Memcached
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
    }
}

Using Cache:
from django.core.cache import cache
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator

# Low-level cache API
def get_post_count():
    count = cache.get('post_count')
    if count is None:
        count = Post.objects.filter(published=True).count()
        cache.set('post_count', count, 300)  # Cache for 5 minutes
    return count

# Cache entire view
@cache_page(60 * 15)  # Cache for 15 minutes
def post_list(request):
    posts = Post.objects.filter(published=True)
    return render(request, 'blog/post_list.html', {'posts': posts})

# Cache class-based view
@method_decorator(cache_page(60 * 15), name='dispatch')
class PostListView(ListView):
    model = Post

# Template fragment caching
{% load cache %}
{% cache 500 sidebar %}
    <!-- Expensive sidebar content -->
{% endcache %}

DEPLOYMENT

Production Settings:
# settings/production.py
from .base import *

DEBUG = False
ALLOWED_HOSTS = ['yourdomain.com', 'www.yourdomain.com']

# Security settings
SECURE_SSL_REDIRECT = True
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME'),
        'USER': os.environ.get('DB_USER'),
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST'),
        'PORT': os.environ.get('DB_PORT'),
    }
}

# Static files
STATIC_ROOT = '/var/www/myproject/static/'
MEDIA_ROOT = '/var/www/myproject/media/'

# Email
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.environ.get('EMAIL_USER')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_PASSWORD')

# Logging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': '/var/log/django/myproject.log',
        },
    },
    'root': {
        'handlers': ['file'],
    },
}

WSGI/ASGI Configuration:
# wsgi.py
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings.production')
application = get_wsgi_application()

# asgi.py (for async support)
import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings.production')
application = get_asgi_application()

Docker Deployment:
# Dockerfile
FROM python:3.11

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

RUN python manage.py collectstatic --noinput

EXPOSE 8000

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "myproject.wsgi:application"]

# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DEBUG=False
      - DATABASE_URL=postgres://user:pass@db:5432/mydb
    depends_on:
      - db

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:

BEST PRACTICES

Security Best Practices:
- Always use HTTPS in production
- Keep SECRET_KEY secret and unique
- Validate and sanitize all user input
- Use Django's built-in protection against CSRF, XSS, SQL injection
- Regularly update dependencies
- Use environment variables for sensitive data
- Implement proper authentication and authorization
- Use Django's security middleware

Performance Optimization:
- Use select_related() and prefetch_related() for database optimization
- Implement caching strategically
- Optimize database indexes
- Use database connection pooling
- Compress static files
- Use CDN for static files
- Monitor and profile your application
- Use pagination for large datasets

Code Organization:
- Follow Django's app structure conventions
- Use meaningful names for models, views, and templates
- Keep views thin, models fat
- Use Django's built-in generic views when appropriate
- Write tests for your code
- Use Django's migration system properly
- Document your code and APIs

Development Workflow:
- Use virtual environments
- Keep requirements.txt updated
- Use version control (Git)
- Set up continuous integration
- Use Django's development server for local development
- Use Django Debug Toolbar for debugging
- Follow PEP 8 style guidelines
- Use Django's management commands for tasks